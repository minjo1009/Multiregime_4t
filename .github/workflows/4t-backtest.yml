name: backtest

on:
  workflow_dispatch:
    inputs:
      data_zip:
        description: '데이터 ZIP 파일명 (레포 루트)'
        required: false
        default: 'ETHUSDT_1min_2020_2025.zip'
      code_zip:
        description: '코드 ZIP 파일명 (레포 루트)'
        required: false
        default: 'trend4u.zip'

permissions:
  contents: read

concurrency:
  group: backtest-${{ github.ref }}
  cancel-in-progress: true

jobs:
  run:
    runs-on: ubuntu-latest
    env:
      TZ: Asia/Seoul
      CODE_ZIP: ${{ github.event.inputs.code_zip || 'trend4u.zip' }}
      DATA_ZIP: ${{ github.event.inputs.data_zip || 'ETHUSDT_1min_2020_2025.zip' }}
      OUT_DIR: _out
      LOG_DIR: _logs
    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 1

      - name: Print context
        run: |
          set -euo pipefail
          echo "Repo: $GITHUB_REPOSITORY" | tee -a context.txt
          echo "SHA : $GITHUB_SHA" | tee -a context.txt
          echo "TZ  : $TZ" | tee -a context.txt
          mkdir -p "$LOG_DIR" "$OUT_DIR"
          mv context.txt "$LOG_DIR/00_context.txt"

      - name: Validate required files
        run: |
          set -euo pipefail
          ls -al
          [[ -f "$CODE_ZIP" ]] || { echo "::error file=$CODE_ZIP::코드 ZIP이 레포 루트에 없습니다."; exit 1; }
          [[ -f "$DATA_ZIP" ]] || { echo "::error file=$DATA_ZIP::데이터 ZIP이 레포 루트에 없습니다."; exit 1; }

      - name: Setup Python
        uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065 # v5.6.0
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Unpack code & data
        run: |
          set -euo pipefail
          unzip -q "$CODE_ZIP" -d code_raw
          unzip -q "$DATA_ZIP" -d data_raw
          # 코드 루트 폴더 추정 (ZIP 안에 단일 상위폴더면 그 폴더, 아니면 code_raw)
          CODE_DIR=$(python - << 'PY'
import os
root='code_raw'
kids=[k for k in os.listdir(root) if not k.startswith('.')]
print(os.path.join(root,kids[0]) if len(kids)==1 and os.path.isdir(os.path.join(root,kids[0])) else root)
PY
)
          echo "CODE_DIR=$CODE_DIR" | tee -a "$LOG_DIR/10_paths.txt"
          # 데이터 파일 경로 추정 (우선순위: ETHUSDT_1min_2020_2025.csv → *.csv)
          DATA_CSV=$(python - << 'PY'
import os,glob
cands=['data_raw/ETHUSDT_1min_2020_2025.csv']+glob.glob('data_raw/**/*.csv',recursive=True)+glob.glob('data_raw/*.csv')
print(cands[0] if cands else '')
PY
)
          if [[ -z "$DATA_CSV" ]]; then
            echo "::warning::CSV 데이터 파일을 찾지 못했습니다. 백테스트 스크립트가 내부에서 읽어올 수도 있습니다."
          else
            echo "DATA_CSV=$DATA_CSV" | tee -a "$LOG_DIR/10_paths.txt"
          fi
          echo "OUT_DIR=$OUT_DIR" | tee -a "$LOG_DIR/10_paths.txt"

          # 코드 루트로 이동용 env 파일 (다음 스텝에서 source)
          echo "export CODE_DIR=\"$CODE_DIR\"" >> $GITHUB_ENV
          echo "export DATA_CSV=\"$DATA_CSV\"" >> $GITHUB_ENV

      - name: Install deps (graceful)
        working-directory: ${{ env.CODE_DIR }}
        run: |
          set -euo pipefail
          python -V | tee -a "../$LOG_DIR/20_versions.txt"
          if [[ -f requirements.txt ]]; then
            pip install -r requirements.txt
          elif [[ -f pyproject.toml ]]; then
            pip install .
          else
            # 최소 구동 세트 (지표/시간/차트)
            pip install numpy pandas matplotlib ta python-dateutil pytz
          fi

      - name: Locate backtest entry
        id: locate
        working-directory: ${{ env.CODE_DIR }}
        run: |
          set -euo pipefail
          # 후보: backtest*.py, run_backtest*.py, main*.py, runner*.py, scripts/* 등
          mapfile -t CANDS < <(git ls-files '*.py' 2>/dev/null || true)
          if [[ ${#CANDS[@]} -eq 0 ]]; then
            # ZIP이 git-tracked가 아니므로 파일시스템 검색
            mapfile -t CANDS < <(ls -1 **/*.py *.py 2>/dev/null || true)
          fi

          pick_script() {
            for pat in 'backtest' 'run_backtest' 'runner' 'main'; do
              for f in "${CANDS[@]}"; do
                [[ "$f" =~ \.venv/|site-packages/ ]] && continue
                [[ "$f" == *"$pat"*".py" ]] && { echo "$f"; return 0; }
              done
            done
            # 마지막 시도로, __main__ 있는 파일
            for f in "${CANDS[@]}"; do
              head -n 200 "$f" | grep -q "__name__ == ['\"]__main__['\"]" && { echo "$f"; return 0; }
            done
            return 1
          }

          ENTRY=$(pick_script || true)
          if [[ -z "$ENTRY" ]]; then
            echo "::warning::엔트리 파이썬 스크립트를 자동탐색하지 못했습니다. 패키지 실행을 시도합니다."
          else
            echo "ENTRY=$ENTRY" | tee -a "../$LOG_DIR/30_entry.txt"
          fi
          echo "entry=$ENTRY" >> $GITHUB_OUTPUT

      - name: Run backtest (best-effort runners)
        working-directory: ${{ env.CODE_DIR }}
        env:
          DATA_CSV: ${{ env.DATA_CSV }}
          OUT_DIR: ${{ env.OUT_DIR }}
          LOG_DIR: ${{ env.LOG_DIR }}
        run: |
          set -euo pipefail
          mkdir -p "../$OUT_DIR" "../$LOG_DIR"
          # 공통 인수 셋업
          ARGS1="--data \"$DATA_CSV\" --out ../$OUT_DIR"
          ARGS2="\"$DATA_CSV\" ../$OUT_DIR"
          ARGS3="--out ../$OUT_DIR"

          # 실행 시나리오: (1) 탐색된 ENTRY 직접 실행 → (2) 패키지 모듈 실행 → (3) scripts 디렉토리 내 실행
          ok=0
          if [[ -n "${{ steps.locate.outputs.entry }}" ]]; then
            ENTRY="${{ steps.locate.outputs.entry }}"
            echo "[try] python $ENTRY $ARGS1" | tee -a "../$LOG_DIR/40_run.txt"
            bash -lc "python \"$ENTRY\" $ARGS1" && ok=1 || true
            if [[ $ok -eq 0 ]]; then
              echo "[fallback] python $ENTRY $ARGS2" | tee -a "../$LOG_DIR/40_run.txt"
              bash -lc "python \"$ENTRY\" $ARGS2" && ok=1 || true
            fi
            if [[ $ok -eq 0 ]]; then
              echo "[fallback] python $ENTRY $ARGS3" | tee -a "../$LOG_DIR/40_run.txt"
              bash -lc "python \"$ENTRY\" $ARGS3" && ok=1 || true
            fi
          fi

          if [[ $ok -eq 0 ]]; then
            # 패키지 실행 시도 (trend4u, trend4t 둘 다 시도)
            for MOD in "trend4u" "trend4t" ; do
              echo "[try] python -m $MOD $ARGS1" | tee -a "../$LOG_DIR/40_run.txt"
              bash -lc "python -m $MOD $ARGS1" && ok=1 && break || true
              echo "[fallback] python -m $MOD $ARGS2" | tee -a "../$LOG_DIR/40_run.txt"
              bash -lc "python -m $MOD $ARGS2" && ok=1 && break || true
              echo "[fallback] python -m $MOD $ARGS3" | tee -a "../$LOG_DIR/40_run.txt"
              bash -lc "python -m $MOD $ARGS3" && ok=1 && break || true
            done
          fi

          if [[ $ok -eq 0 && -d scripts ]]; then
            for s in scripts/*.py; do
              [[ -f "$s" ]] || continue
              echo "[try] python $s $ARGS1" | tee -a "../$LOG_DIR/40_run.txt"
              bash -lc "python \"$s\" $ARGS1" && ok=1 && break || true
            done
          fi

          if [[ $ok -eq 0 ]]; then
            echo "::error::백테스트 엔트리 실행에 실패했습니다. _logs/40_run.txt를 확인하세요."
            exit 1
          fi

          # 결과물 없으면 기본 리포트라도 생성
          if [[ -z "$(ls -A ../$OUT_DIR 2>/dev/null || true)" ]]; then
            echo "no explicit outputs; generating basic summary" | tee -a "../$LOG_DIR/50_post.txt"
            python - <<'PY' "../$LOG_DIR/50_post.txt" "../$OUT_DIR/README.txt"
import os,sys,datetime
log=sys.argv[1]; out=sys.argv[2]
os.makedirs(os.path.dirname(out),exist_ok=True)
open(out,'w').write(f"Backtest finished at {datetime.datetime.now()}\nCheck logs in _logs\n")
open(log,'a').write("Wrote fallback README.txt\n")
PY
          fi

      - name: Upload OUT
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: backtest-out
          path: ${{ github.workspace }}/${{ env.OUT_DIR }}/
          if-no-files-found: warn
          retention-days: 7

      - name: Upload LOGS
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: backtest-logs
          path: ${{ github.workspace }}/${{ env.LOG_DIR }}/
          if-no-files-found: warn
          retention-days: 14
