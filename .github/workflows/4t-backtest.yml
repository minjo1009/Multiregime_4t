name: 4u Backtest (pure bash)

on:
  workflow_dispatch:
    inputs:
      run_args:
        description: '추가 실행 인수 (있으면 그대로 덧붙임)'
        required: false
        default: ''
      results_branch:
        description: '결과 커밋 브랜치'
        required: false
        default: 'backtest-results'
  push:
    branches: [ main ]
    paths:
      - 'trend4u.zip'
      - 'ETHUSDT_1min_2020_2025.zip'
      - '.github/workflows/4t-backtest.yml'

permissions:
  contents: write

jobs:
  backtest:
    runs-on: ubuntu-latest
    env:
      TZ: Asia/Seoul
      SRC_DIR: ${{ github.workspace }}/src
      DATA_DIR: ${{ github.workspace }}/data
      OUT_DIR:  ${{ github.workspace }}/_out
      LOG_DIR:  ${{ github.workspace }}/_logs
      RESULTS_BRANCH: ${{ inputs.results_branch }}
    steps:
      - name: Checkout (no external action)
        shell: bash
        env:
          REPO:  ${{ github.repository }}
          SHA:   ${{ github.sha }}
          TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -Eeuo pipefail
          mkdir -p "$LOG_DIR"
          echo "Repo: $REPO"  | tee -a "$LOG_DIR/context.txt"
          echo "SHA : $SHA"   | tee -a "$LOG_DIR/context.txt"
          echo "TZ  : $TZ"    | tee -a "$LOG_DIR/context.txt"

          git init
          git remote add origin "https://x-access-token:${TOKEN}@github.com/${REPO}.git"
          git -c protocol.version=2 fetch --depth=1 origin "$SHA"
          git checkout --force FETCH_HEAD

      - name: Prepare folders
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p "$SRC_DIR" "$DATA_DIR" "$OUT_DIR" "$LOG_DIR"
          ls -la | tee -a "$LOG_DIR/steps.txt"

      - name: Unpack code (trend4u.zip) → src/
        shell: bash
        run: |
          set -Eeuo pipefail
          if [[ -f trend4u.zip ]]; then
            echo "Using trend4u.zip" | tee -a "$LOG_DIR/steps.txt"
            rm -rf _code_tmp && mkdir -p _code_tmp
            unzip -q trend4u.zip -d _code_tmp
            if [[ -d _code_tmp/trend4u ]]; then
              rsync -a _code_tmp/trend4u/ "$SRC_DIR"/trend4u/
            elif [[ -d _code_tmp/src ]]; then
              rsync -a _code_tmp/src/ "$SRC_DIR"/
            else
              rsync -a _code_tmp/ "$SRC_DIR"/
            fi
            rm -rf _code_tmp
          elif [[ -d src ]]; then
            rsync -a src/ "$SRC_DIR"/
          elif [[ -d trend4u ]]; then
            rsync -a trend4u/ "$SRC_DIR"/trend4u/
          else
            echo "::error::trend4u.zip, src/, trend4u/ 중 아무것도 없음"; exit 1
          fi

          # 오래된 __init__ 문법 점검(수정은 하지 않지만 로그는 남김)
          INIT="$SRC_DIR/trend4u/trend4p/__init__.py"
          if [[ -f "$INIT" ]]; then
            head -n 3 "$INIT" | tee -a "$LOG_DIR/steps.txt" || true
          fi

          echo "[src tree]" | tee -a "$LOG_DIR/steps.txt"
          (cd "$SRC_DIR" && find . -maxdepth 3 -type f | sort) | tee -a "$LOG_DIR/src_tree.txt"

      - name: Prepare data (ETHUSDT_1min_2020_2025.zip or CSV)
        shell: bash
        run: |
          set -Eeuo pipefail
          if [[ -f ETHUSDT_1min_2020_2025.zip ]]; then
            echo "Using ETHUSDT_1min_2020_2025.zip" | tee -a "$LOG_DIR/steps.txt"
            unzip -q ETHUSDT_1min_2020_2025.zip -d "$DATA_DIR"
          else
            shopt -s nullglob
            CSV=(ETHUSDT_1min_2020_2025.csv *.csv)
            if [[ ${#CSV[@]} -gt 0 ]]; then
              cp -f "${CSV[@]}" "$DATA_DIR"/
            else
              echo "::warning::데이터 ZIP/CSV가 없습니다."
            fi
          fi
          echo "[data tree]" | tee -a "$LOG_DIR/steps.txt"
          (cd "$DATA_DIR" && ls -la) | tee -a "$LOG_DIR/steps.txt" || true

      - name: Install deps (python3 -m pip)
        shell: bash
        run: |
          set -Eeuo pipefail
          python3 --version | tee -a "$LOG_DIR/versions.txt"
          if [[ -f requirements.txt ]]; then
            python3 -m pip install --upgrade pip
            python3 -m pip install -r requirements.txt
          elif [[ -f "$SRC_DIR/requirements.txt" ]]; then
            python3 -m pip install --upgrade pip
            python3 -m pip install -r "$SRC_DIR/requirements.txt"
          elif [[ -f pyproject.toml ]]; then
            python3 -m pip install --upgrade pip
            python3 -m pip install .
          else
            python3 -m pip install --upgrade pip
            python3 -m pip install numpy pandas matplotlib ta scikit-learn python-dateutil pytz
          fi

      - name: Run backtest
        shell: bash
        env:
          EXTRA_ARGS: ${{ inputs.run_args }}
        run: |
          set -Eeuo pipefail
          export PYTHONPATH="${PYTHONPATH:-${GITHUB_WORKSPACE}/src}:${GITHUB_WORKSPACE}/src/trend4u"
          echo "PYTHONPATH=$PYTHONPATH" | tee -a "$LOG_DIR/steps.txt"

          # 1) 데이터 CSV 자동 탐색
          DATA_CSV="$(ls -1 "$DATA_DIR"/*.csv 2>/dev/null | head -n1 || true)"
          if [[ -z "${DATA_CSV:-}" ]]; then
            echo "::error::data/*.csv를 찾지 못했습니다."; exit 1
          fi
          echo "DATA_CSV=$DATA_CSV" | tee -a "$LOG_DIR/steps.txt"

          # 2) CSV에서 날짜 컬럼 자동 감지 & train/test 구간 80/20 산출
          python3 - "$DATA_CSV" >"$LOG_DIR/range.json" <<'PY'
import sys, json, pandas as pd
p = sys.argv[1]
# 메모리 고려해 nrows/skiprows 샘플링으로 최소/최대 시각 추정
try:
    df_head = pd.read_csv(p, nrows=500)
except Exception:
    df_head = pd.read_csv(p)
# 날짜형 컬럼 자동 탐지(첫 날짜형 컬럼)
dt_cols = [c for c in df_head.columns if pd.api.types.is_datetime64_any_dtype(df_head[c]) or
           (df_head[c].astype(str).str.match(r'\d{4}-\d{2}-\d{2}').any())]
if not dt_cols:
    # 첫 컬럼을 날짜로 가정
    dt_col = df_head.columns[0]
else:
    dt_col = dt_cols[0]
# 전체 범위 얻기 위해 최소/최대만 읽어서 변환(빠름)
full = pd.read_csv(p, usecols=[dt_col])
full[dt_col] = pd.to_datetime(full[dt_col], errors='coerce', utc=True).dt.tz_convert(None)
full = full.dropna(subset=[dt_col])
start = full[dt_col].min().date()
end   = full[dt_col].max().date()
# 80/20 split
cut = start + (end - start) * 8 // 10
out = {
  "train_start": str(start),
  "train_end":   str(cut),
  "test_start":  str(cut),
  "test_end":    str(end)
}
print(json.dumps(out))
PY
          cat "$LOG_DIR/range.json" | tee -a "$LOG_DIR/steps.txt"

          TRAIN_START="$(jq -r .train_start "$LOG_DIR/range.json")"
          TRAIN_END="$(jq -r .train_end "$LOG_DIR/range.json")"
          TEST_START="$(jq -r .test_start "$LOG_DIR/range.json")"
          TEST_END="$(jq -r .test_end "$LOG_DIR/range.json")"

          # 3) 실행 (필수 인자 모두 제공)
          set +e
          python3 -m trend4u.run_4u \
            --data "$DATA_CSV" \
            --train_start "$TRAIN_START" --train_end "$TRAIN_END" \
            --test_start "$TEST_START"   --test_end "$TEST_END" \
            --out_dir "$OUT_DIR" \
            ${EXTRA_ARGS} 2>&1 | tee "$LOG_DIR/backtest_stdout.txt"
          rc=${PIPESTATUS[0]}
          set -e
          echo "exit_code=$rc" | tee -a "$LOG_DIR/steps.txt"
          echo "$rc" > "$LOG_DIR/exit_code.txt"
          test "$rc" -eq 0

      - name: Collect artifacts → _out/
        if: always()
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p "$OUT_DIR"
          find "$GITHUB_WORKSPACE" -maxdepth 4 -type f \( \
            -name 'train_test_summary.json' -o \
            -name 'backtest_summary.json' -o \
            -name 'equity_curve*.csv' -o \
            -name 'trades*.csv' -o \
            -name 'report*.html' -o \
            -name 'fig_*.png' \
          \) -print0 | while IFS= read -r -d '' p; do cp "$p" "$OUT_DIR"/ || true; done
          (cd "$OUT_DIR" && ls -la) | tee -a "$LOG_DIR/steps.txt" || true

      - name: Publish results to branch (no external action)
        if: always()
        shell: bash
        env:
          TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -Eeuo pipefail
          BR="$RESULTS_BRANCH"
          RUN_DIR="_runs/${GITHUB_RUN_ID}"
          TMP="$(mktemp -d)"
          mkdir -p "$TMP/${RUN_DIR}"
          rsync -a "$OUT_DIR"/ "$TMP/${RUN_DIR}/" || true
          rsync -a "$LOG_DIR"/ "$TMP/${RUN_DIR}/logs/" || true
          ( cd "$TMP"
            git init
            git config user.name  "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git remote add origin "https://x-access-token:${TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
            git fetch origin "$BR" || true
            git checkout -B "$BR"
            git add .
            git commit -m "Backtest run ${GITHUB_RUN_ID} (SHA ${GITHUB_SHA})" || true
            git push -f origin "$BR"
          )
          echo "pushed: $BR / $RUN_DIR" | tee -a "$LOG_DIR/steps.txt"

      - name: Job summary
        if: always()
        shell: bash
        run: |
          set -Eeuo pipefail
          {
            echo "## 4u Backtest — Summary"
            if [[ -f "$OUT_DIR/train_test_summary.json" ]]; then
              echo ""
              echo "\`\`\`json"; sed -n '1,200p' "$OUT_DIR/train_test_summary.json"; echo "\`\`\`"
            else
              echo "- No train_test_summary.json generated."
            fi
            echo ""
            echo "### Logs"
            echo "- **context.txt**";  echo '```'; sed -n '1,120p' "$LOG_DIR/context.txt" 2>/dev/null; echo '```'
            echo "- **exit_code**: $(cat "$LOG_DIR/exit_code.txt" 2>/dev/null || echo 'n/a')"
          } >> "$GITHUB_STEP_SUMMARY"