name: 4T Backtest (self-contained, no marketplace actions)

on:
  workflow_dispatch:
    inputs:
      python:
        description: "Python version (러너 기본 python3 사용: 무시 가능)"
        required: false
        default: "system"
      code_zip:
        description: "코드 zip 파일명(레포 루트)"
        required: false
        default: "trend4u.zip"
      data_zip:
        description: "데이터 zip 파일명(레포 루트, 없으면 건너뜀)"
        required: false
        default: "ETH_1min.zip"

permissions:
  contents: read

env:
  TZ: Asia/Seoul
  CODE_ZIP: ${{ github.event.inputs.code_zip || 'trend4u.zip' }}
  DATA_ZIP: ${{ github.event.inputs.data_zip || 'ETH_1min.zip' }}
  OUT_DIR: out
  LOG_DIR: logs

jobs:
  backtest:
    runs-on: ubuntu-latest
    steps:
      - name: Print base env
        shell: bash
        run: |
          set -euo pipefail
          echo "Repo      : $GITHUB_REPOSITORY"
          echo "Commit    : $GITHUB_SHA"
          echo "Workspace : $GITHUB_WORKSPACE"
          echo "TZ        : $TZ"

      - name: Prepare workspace (no checkout)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$GITHUB_WORKSPACE/${{ env.LOG_DIR }}" "$GITHUB_WORKSPACE/${{ env.OUT_DIR }}"
          echo "Logs at:    $GITHUB_WORKSPACE/${{ env.LOG_DIR }}"
          echo "Outputs at: $GITHUB_WORKSPACE/${{ env.OUT_DIR }}"
          # 현재 커밋의 소스 zipball 다운로드 (checkout 액션 대체)
          API_ZIP="https://api.github.com/repos/${GITHUB_REPOSITORY}/zipball/${GITHUB_SHA}"
          echo "Downloading source zipball for current SHA..."
          curl -sSL -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" -H "X-GitHub-Api-Version: 2022-11-28" "$API_ZIP" -o source.zip
          unzip -q source.zip
          ROOT_DIR="$(ls -d ${GITHUB_REPOSITORY#*/}-*/ || true)"
          if [[ -z "${ROOT_DIR:-}" ]]; then
            echo "❌ Failed to expand repo archive directory name."
            exit 1
          fi
          echo "Expanded root: $ROOT_DIR"
          # 작업 디렉토리로 이동
          mv "$ROOT_DIR" repo
          cd repo
          echo "$(pwd)" > ../${{ env.LOG_DIR }}/pwd.txt
          echo "Repo tree (top-level):" | tee ../${{ env.LOG_DIR }}/tree_top.txt
          ls -la | tee -a ../${{ env.LOG_DIR }}/tree_top.txt

          # 루트에 존재해야 하는 코드/데이터 zip 복사(있는 경우)
          for Z in "${CODE_ZIP}" "${DATA_ZIP}"; do
            if [[ -f "../$Z" ]]; then
              cp "../$Z" "./$Z"
            fi
          done

      - name: Python venv & deps
        shell: bash
        working-directory: repo
        run: |
          set -euo pipefail
          python3 --version | tee -a ../${{ env.LOG_DIR }}/versions.txt
          python3 -m venv .venv
          source .venv/bin/activate
          python -m pip install --upgrade pip wheel >/dev/null
          if [[ -f requirements.txt ]]; then
            pip install -r requirements.txt
          elif [[ -f pyproject.toml ]]; then
            pip install .
          else
            pip install numpy pandas matplotlib ta python-dateutil pytz
          fi
          python -V | tee -a ../${{ env.LOG_DIR }}/versions.txt
          pip list | tee ../${{ env.LOG_DIR }}/pip_list.txt

      - name: Unzip code & data
        shell: bash
        working-directory: repo
        run: |
          set -euo pipefail
          source .venv/bin/activate
          shopt -s nullglob
          # 코드 zip
          if [[ -f "${CODE_ZIP}" ]]; then
            echo "Unzipping code: ${CODE_ZIP}"
            mkdir -p code
            unzip -q "${CODE_ZIP}" -d code
          else
            echo "⚠️ code zip not found at repo root: ${CODE_ZIP}"
          fi
          # 데이터 zip
          if [[ -f "${DATA_ZIP}" ]]; then
            echo "Unzipping data: ${DATA_ZIP}"
            mkdir -p data
            unzip -q "${DATA_ZIP}" -d data
          else
            echo "ℹ️ data zip not found: ${DATA_ZIP} (skip)"
          fi
          echo "Tree snapshot:" | tee ../${{ env.LOG_DIR }}/tree_after_unzip.txt
          find . -maxdepth 2 -type d -print | sort | tee -a ../${{ env.LOG_DIR }}/tree_after_unzip.txt
          find . -maxdepth 2 -type f -name "*.py" | sort | tee ../${{ env.LOG_DIR }}/py_files.txt || true

      - name: Auto-detect backtest entry & run
        shell: bash
        working-directory: repo
        env:
          PYTHONUNBUFFERED: "1"
        run: |
          set -euo pipefail
          source .venv/bin/activate

          # 공통 환경변수: 코드/데이터 루트 추정
          CODE_ROOT="."
          DATA_ROOT="."
          if [[ -d "code" ]]; then CODE_ROOT="code"; fi
          if [[ -d "data" ]]; then DATA_ROOT="data"; fi
          echo "CODE_ROOT=$CODE_ROOT" | tee ../${{ env.LOG_DIR }}/env_guess.txt
          echo "DATA_ROOT=$DATA_ROOT" | tee -a ../${{ env.LOG_DIR }}/env_guess.txt

          # 우선순위 엔트리 후보
          declare -a CANDIDATES=(
            "backtest.py"
            "run_backtest.py"
            "scripts/backtest.py"
            "src/backtest.py"
          )

          SELECTED=""
          for f in "${CANDIDATES[@]}"; do
            if [[ -f "$f" ]]; then SELECTED="$f"; break; fi
            if [[ -f "$CODE_ROOT/$f" ]]; then SELECTED="$CODE_ROOT/$f"; break; fi
          done

          if [[ -z "${SELECTED}" ]]; then
            # 마지막 안전장치: __main__ 있는 *.py 자동 탐색
            SELECTED="$(grep -RIl --include="*.py" '__main__' "$CODE_ROOT" . 2>/dev/null | head -n 1 || true)"
          fi

          if [[ -z "${SELECTED}" ]]; then
            echo "❌ 백테스트 실행 스크립트를 찾지 못했습니다."
            echo "다음 중 하나 이름으로 루트 또는 code/ 에 파일을 두세요:"
            printf ' - backtest.py\n - run_backtest.py\n - scripts/backtest.py\n - src/backtest.py\n'
            echo "레포 루트 2단계 트리:"
            find . -maxdepth 2 -print
            # 도움 로그 남기고 실패
            echo "NO_ENTRY=1" > ../${{ env.OUT_DIR }}/summary.txt
            exit 2
          fi

          echo "▶ 실행 엔트리: $SELECTED"
          # 가벼운 러너: 공통 인자 표준화
          RUN_CMD=( python "$SELECTED" )
          # 관례 인자 지원: --data-dir / --code-dir / --out-dir 중 존재하면 전달
          HELP_TXT="$(python "$SELECTED" --help 2>&1 || true)"
          [[ "$HELP_TXT" == *"--data-dir"* ]] && RUN_CMD+=( --data-dir "$DATA_ROOT" )
          [[ "$HELP_TXT" == *"--code-dir"* ]] && RUN_CMD+=( --code-dir "$CODE_ROOT" )
          [[ "$HELP_TXT" == *"--out-dir"*  ]] && RUN_CMD+=( --out-dir "../${{ env.OUT_DIR }}" )

          echo "RUN_CMD: ${RUN_CMD[*]}" | tee ../${{ env.LOG_DIR }}/run_cmd.txt

          set +e
          "${RUN_CMD[@]}" 2>&1 | tee ../${{ env.LOG_DIR }}/backtest_run.log
          RET=${PIPESTATUS[0]}
          set -e
          echo "Exit code: $RET" | tee -a ../${{ env.LOG_DIR }}/backtest_run.log

          # out 디렉토리 보장 + 기본 요약 생성
          mkdir -p ../${{ env.OUT_DIR }}
          if [[ ! -s ../${{ env.OUT_DIR }}/summary.txt ]]; then
            echo "ENTRY=$SELECTED" > ../${{ env.OUT_DIR }}/summary.txt
            echo "EXIT_CODE=$RET" >> ../${{ env.OUT_DIR }}/summary.txt
            # 결과 산출물이 하나도 없다면 더미 생성(경고 방지)
            if ! compgen -G "../${{ env.OUT_DIR }}/*" > /dev/null; then
              echo "No user artifacts produced; creating placeholder." >> ../${{ env.OUT_DIR }}/summary.txt
              echo "placeholder=$(date -Iseconds)" > ../${{ env.OUT_DIR }}/placeholder.txt
            fi
          fi

          # 실패 시에도 워크플로우는 성공/실패를 명확히 표기
          if [[ $RET -ne 0 ]]; then
            echo "❗ 백테스트 스크립트가 비정상 종료했습니다 (code=$RET)."
            exit $RET
          fi

      - name: Job summary
        shell: bash
        run: |
          set -euo pipefail
          echo "## Backtest Job Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- Out dir  : \`${{ env.OUT_DIR }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Logs dir : \`${{ env.LOG_DIR }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### versions.txt" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          cat ${{ env.LOG_DIR }}/versions.txt || true >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### run_cmd" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          cat ${{ env.LOG_DIR }}/run_cmd.txt || true >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### summary.txt" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          cat ${{ env.OUT_DIR }}/summary.txt || true >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

      # (선택) 결과를 브랜치에 커밋/푸시하고 싶다면 주석 해제 + permissions.contents: write 로 변경
      # - name: Commit results to branch
      #   if: ${{ always() }}
      #   shell: bash
      #   run: |
      #     set -euo pipefail
      #     BR="backtest-results"
      #     git config --global user.email "actions@users.noreply.github.com"
      #     git config --global user.name "github-actions"
      #     git init pushrepo
      #     cd pushrepo
      #     git remote add origin "https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${GITHUB_REPOSITORY}.git"
      #     git checkout -b "$BR"
      #     mkdir -p "${{ env.OUT_DIR }}" "${{ env.LOG_DIR }}"
      #     cp -r "$GITHUB_WORKSPACE/${{ env.OUT_DIR }}"/* "${{ env.OUT_DIR }}" 2>/dev/null || true
      #     cp -r "$GITHUB_WORKSPACE/${{ env.LOG_DIR }}"/* "${{ env.LOG_DIR }}" 2>/dev/null || true
      #     git add -A
      #     git commit -m "Backtest results for ${GITHUB_SHA::7}"
      #     git push -u origin "$BR" --force
