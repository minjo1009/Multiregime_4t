# .github/workflows/4t-backtest.yml
name: 4u Backtest

on:
  workflow_dispatch:
    inputs:
      code_zip:
        description: '코드 ZIP 파일명 (루트, 기본: trend4u.zip 검색형)'
        required: false
        default: ''
      data_zip:
        description: '데이터 ZIP 파일명 (루트, 기본: ETH*1min*2025*.zip 검색형)'
        required: false
        default: ''
      data_csv_glob:
        description: 'CSV 글롭 (데이터zip 없을 때 루트/경로 검색용)'
        required: false
        default: 'ETH*1min*2025*.csv'

jobs:
  backtest:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: read
      id-token: write

    env:
      TZ: Asia/Seoul
      # 산출물/로그/작업폴더
      OUT_DIR: _out
      LOG_DIR: _logs
      SRC_DIR: src
      DATA_DIR: data

    steps:
      # 1) 체크아웃 (풀 SHA 고정 필수)
      - name: Checkout
        uses: actions/checkout@PINNED_SHA_CHECKOUT

      # 2) Python 세팅 (풀 SHA 고정 필수)
      - name: Setup Python
        uses: actions/setup-python@PINNED_SHA_SETUP_PY
        with:
          python-version: '3.12'

      # 3) 기본 폴더 준비 + 컨텍스트 로그
      - name: Prepare folders & echo context
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p "$OUT_DIR" "$LOG_DIR" "$SRC_DIR" "$DATA_DIR"
          {
            echo "Repo: $GITHUB_REPOSITORY"
            echo "SHA : $GITHUB_SHA"
            echo "TZ  : $TZ"
          } | tee "$LOG_DIR/context.txt"
          python -V | tee "$LOG_DIR/versions.txt"

      # 4) 코드 ZIP 자동 탐색/해체 + 패키지 핫픽스
      - name: Unpack code zip (trend4u*.zip) to src/
        shell: bash
        run: |
          set -Eeuo pipefail

          # 4-1) 코드 ZIP 결정 (입력 > 루트 검색)
          WANT="${{ github.event.inputs.code_zip }}"
          if [[ -n "${WANT}" && -f "${WANT}" ]]; then
            CODE_ZIP="${WANT}"
          else
            CODE_ZIP="$(ls -1 . | grep -E '^trend4u.*\.zip$' | head -n1 || true)"
          fi

          if [[ -z "${CODE_ZIP:-}" ]]; then
            echo "ERROR: trend4u*.zip not found at repo root."
            echo "현재 파일 목록:"; ls -la .
            exit 1
          fi
          echo "Using code zip: ${CODE_ZIP}" | tee -a "$LOG_DIR/steps.txt"

          # 4-2) 해체
          unzip -q "${CODE_ZIP}" -d _code_tmp

          # 4-3) 트리 정규화: src/가 zip 내부에 없으면 맞춰 넣기
          if [[ -d _code_tmp/src ]]; then
            rsync -a _code_tmp/src/ "$SRC_DIR"/
          elif [[ -d _code_tmp/trend4u ]]; then
            mkdir -p "$SRC_DIR"
            rsync -a _code_tmp/trend4u/ "$SRC_DIR"/trend4u/
          else
            # 최상단이 trend4u/도 아니면 전부 src/로 이식
            rsync -a _code_tmp/ "$SRC_DIR"/
          fi
          rm -rf _code_tmp

          # 4-4) 패키지 레이아웃 보정
          # trend4u 패키지 보장
          if [[ ! -f "$SRC_DIR/trend4u/__init__.py" ]]; then
            mkdir -p "$SRC_DIR/trend4u"
            printf "__all__ = []\n" > "$SRC_DIR/trend4u/__init__.py"
          fi

          # trend4p 서브패키지 보장 + __init__ 문법 핫픽스
          mkdir -p "$SRC_DIR/trend4u/trend4p"
          if [[ -f "$SRC_DIR/trend4u/trend4p/__init__.py" ]]; then
            # 흔한 오류: '.__all__ = ...' 같은 잘못된 문법
            if grep -q "^\.\s*__all__" "$SRC_DIR/trend4u/trend4p/__init__.py"; then
              sed -i 's/^\.\s*__all__/__all__/g' "$SRC_DIR/trend4u/trend4p/__init__.py"
            fi
          else
            cat > "$SRC_DIR/trend4u/trend4p/__init__.py" <<'PY'
__all__ = ['data_utils','features_4u','labeling','model_4u','execution_4u','selector_4u']
PY
          fi

          # run_4u.py 위치 표준화 (없으면 런치 스텁 생성)
          if [[ ! -f "$SRC_DIR/trend4u/run_4u.py" ]]; then
            cat > "$SRC_DIR/trend4u/run_4u.py" <<'PY'
import os
import sys

# PYTHONPATH에 src 가 들어오므로 trend4u 패키지로 접근 가능
from trend4u.trend4p.execution_4u import backtest

def main():
    data_dir = os.environ.get("DATA_DIR", "data")
    out_dir  = os.environ.get("OUT_DIR", "_out")
    os.makedirs(out_dir, exist_ok=True)
    # 백테스트 엔트리포인트 시그니처가 다르면 여기서 맞춰 매핑
    backtest(data_dir=data_dir, out_dir=out_dir)

if __name__ == "__main__":
    main()
PY
          fi

          echo "==== SRC tree ====" | tee -a "$LOG_DIR/steps.txt"
          (cd "$SRC_DIR" && find . -maxdepth 3 -type f | sort) | tee -a "$LOG_DIR/steps.txt"

      # 5) 데이터 ZIP/CSV 수급 및 해체
      - name: Unpack data (ETHUSDT 1min) to data/
        shell: bash
        run: |
          set -Eeuo pipefail
          WANT="${{ github.event.inputs.data_zip }}"
          CSV_GLOB="${{ github.event.inputs.data_csv_glob }}"

          # 우선 ZIP을 찾는다 (입력 > 루트 검색)
          if [[ -n "${WANT}" && -f "${WANT}" ]]; then
            DATA_ZIP="${WANT}"
          else
            DATA_ZIP="$(ls -1 . | grep -E '^ETH.*1min.*(2025|2020).*\.zip$' | head -n1 || true)"
          fi

          if [[ -n "${DATA_ZIP:-}" ]]; then
            echo "Using data zip: ${DATA_ZIP}" | tee -a "$LOG_DIR/steps.txt"
            unzip -q "${DATA_ZIP}" -d "$DATA_DIR"
          else
            echo "data zip not found, try CSV fallback: ${CSV_GLOB}" | tee -a "$LOG_DIR/steps.txt"
            shopt -s nullglob
            CSV=($CSV_GLOB)
            if [[ ${#CSV[@]} -gt 0 ]]; then
              mkdir -p "$DATA_DIR"
              for f in "${CSV[@]}"; do cp "$f" "$DATA_DIR/"; done
            else
              echo "ERROR: 데이터 ZIP/CSV 모두 찾지 못함."
              echo "루트 파일 목록:"; ls -la .
              exit 1
            fi
          fi

          echo "==== DATA tree ====" | tee -a "$LOG_DIR/steps.txt"
          (cd "$DATA_DIR" && ls -la) | tee -a "$LOG_DIR/steps.txt"

          # CSV 최소 유효성
          CSV_FOUND=$(find "$DATA_DIR" -maxdepth 2 -type f -name '*.csv' | head -n1 || true)
          if [[ -z "${CSV_FOUND:-}" ]]; then
            echo "ERROR: data/ 내 CSV가 없습니다."
            exit 1
          fi
          head -n 5 "$CSV_FOUND" | tee "$LOG_DIR/sample_data_head.txt"

      # 6) 의존성 설치 (레포/zip 내부에 requirements 있으면 우선)
      - name: Install Python deps
        shell: bash
        run: |
          set -Eeuo pipefail
          if [[ -f "requirements.txt" ]]; then
            pip install -r requirements.txt
          elif [[ -f "$SRC_DIR/requirements.txt" ]]; then
            pip install -r "$SRC_DIR/requirements.txt"
          elif [[ -f "pyproject.toml" ]]; then
            pip install .
          else
            pip install numpy pandas matplotlib ta scikit-learn python-dateutil pytz
          fi

      # 7) 백테스트 실행
      - name: Run backtest
        shell: bash
        env:
          PYTHONPATH: ${{ github.workspace }}/src
        run: |
          set -Eeuo pipefail
          echo "PYTHONPATH=$PYTHONPATH" | tee -a "$LOG_DIR/steps.txt"
          python -m trend4u.run_4u 2>&1 | tee "$LOG_DIR/backtest_stdout.txt"

          # 대표 산출물 수집 (이름이 다르면 여기서 추가로 복사)
          mkdir -p "$OUT_DIR"
          # 흔히 생성하는 파일들 탐색/복사
          for f in \
            train_test_summary.json \
            backtest_summary.json \
            metrics.json \
            equity_curve*.csv \
            trades*.csv \
            report*.html \
            fig_*.png ; do
            if compgen -G "$f" > /dev/null; then
              cp $f "$OUT_DIR"/ || true
            fi
          done

          # 모듈 내부에서 만든 산출물도 스캔
          find . -maxdepth 3 -type f -name 'train_test_summary.json' -o -name 'backtest_summary.json' -o -name 'equity_curve*.csv' -o -name 'trades*.csv' -o -name 'report*.html' -o -name 'fig_*.png' | while read -r p; do
            cp "$p" "$OUT_DIR"/ || true
          done

          # 산출물 유효성
          if [[ -z "$(ls -A "$OUT_DIR" 2>/dev/null)" ]]; then
            echo "WARN: 산출물을 찾지 못했습니다. 코드 내부의 출력 경로(out_dir)를 확인하세요." | tee -a "$LOG_DIR/steps.txt"
          fi

      # 8) 아티팩트 업로드 (풀 SHA 고정 필수)
      - name: Upload artifacts (results)
        if: always()
        uses: actions/upload-artifact@PINNED_SHA_UPLOAD
        with:
          name: out
          path: |
            _out/**
            _logs/**
          if-no-files-found: warn