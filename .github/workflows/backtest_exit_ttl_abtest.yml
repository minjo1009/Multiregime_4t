name: Exit/TTL A-B (param v2, pinned)

on:
  workflow_dispatch:
    inputs:
      CODEPACK_ZIP:
        description: "Path to code pack zip at repo root"
        required: true
        default: "trade_v1.1.4.zip"
      CSV_GLOB:
        description: "Glob for CSV under tmp/data or data"
        required: true
        default: "**/*ETHUSDT*1min*2020*2025*.csv"
      TTL_A:
        description: "Exit TTL for run A"
        required: true
        default: "1"
      TTL_B:
        description: "Exit TTL for run B"
        required: true
        default: "5000"

jobs:
  abtest:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Checkout (pinned SHA)
        uses: actions/checkout@11bd71901b5b5b1630b4b23b5b2ac60a8a6e3f2

      - name: Setup Python 3.11 (pinned SHA)
        uses: actions/setup-python@a26af69be951a213e376a39fc6824e9f5b089bc5
        with:
          python-version: '3.11'

      - name: Install deps
        shell: bash
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          pip install pyyaml

      - name: Prepare workspace
        shell: bash
        env:
          CODEPACK_ZIP: ${{ github.event.inputs.CODEPACK_ZIP }}
          CSV_GLOB: ${{ github.event.inputs.CSV_GLOB }}
        run: |
          set -euo pipefail
          mkdir -p _out_4u tmp/trade tmp/data
          echo "[prep] unzip ${CODEPACK_ZIP} -> tmp/trade"
          unzip -o "${CODEPACK_ZIP}" -d tmp/trade >/dev/null
          echo "[prep] select CSV with glob: ${CSV_GLOB}"
          SEL=$(python - <<'PY'
          import os, glob
          pat = os.environ.get("CSV_GLOB","**/*.csv")
          c = sorted(glob.glob("tmp/data/"+pat, recursive=True))
          if not c:
              c = sorted(glob.glob("data/"+pat, recursive=True))
          print(c[0] if c else "")
          PY
          )
          if [ -z "${SEL}" ]; then
            echo "No CSV found under tmp/data or data"; exit 1
          fi
          echo "${SEL}" > _out_4u/CSV_PATH.txt
          echo "[prep] CSV selected: ${SEL}"

      - name: Create run_engine.py (bridge)
        shell: bash
        run: |
          set -euo pipefail
          cat > run_engine.py <<'PY'
          import os, sys, glob, subprocess
          from pathlib import Path

          ROOT = Path("tmp/trade")
          CONF = ROOT / "conf" / "config.effective.yml"
          OUT  = Path("_out_4u")
          OUT.mkdir(parents=True, exist_ok=True)

          data_path = Path("_out_4u/CSV_PATH.txt").read_text().strip()

          candidates = [
              ("run_4u", ROOT / "run_4u.py"),
              ("runner", ROOT / "backtest" / "runner.py"),
              ("engine", ROOT / "backtest" / "engine.py"),
          ]

          args = None
          used = None
          for name, p in candidates:
              if p.exists():
                  used = str(p)
                  if name in ("run_4u", "runner"):
                      args = ["python","-u",str(p),"--data_path",data_path,"--config",str(CONF),"--out_dir",str(OUT)]
                  else:
                      args = ["python","-u",str(p),"--data_path",data_path,"--config",str(CONF)]
                  break

          if not args:
              raise FileNotFoundError("No engine entry found (run_4u.py or backtest/runner.py or backtest/engine.py)")

          print("[engine] using", used)
          subprocess.run(args, check=True)

          # normalize/copy trades.csv to OUT/trades.csv if nested
          t = OUT / "trades.csv"
          if not t.exists():
              cand = glob.glob(str(OUT / "**" / "trades.csv"), recursive=True)
              if cand:
                  Path(cand[0]).rename(t)
          PY

      - name: Patch TTL in config (A)
        shell: bash
        env:
          TTL: ${{ github.event.inputs.TTL_A }}
        run: |
          set -euo pipefail
          CONF=tmp/trade/conf/config.effective.yml
          mkdir -p tmp/trade/conf
          python - <<'PY'
          import os, yaml, pathlib
          p = pathlib.Path("tmp/trade/conf/config.effective.yml")
          cfg = {}
          if p.exists():
              try:
                  import yaml as _y; cfg = _y.safe_load(p.read_text()) or {}
              except Exception:
                  cfg = {}
          cfg.setdefault("exit",{})
          cfg["exit"]["ttl"] = int(os.environ.get("TTL","0"))
          p.write_text(yaml.safe_dump(cfg, sort_keys=False))
          print("[patchA] ttl ->", cfg["exit"]["ttl"])
          PY

      - name: Run A (TTL=A)
        shell: bash
        run: |
          set -euo pipefail
          python -u run_engine.py
          test -f _out_4u/trades.csv
          cp -f _out_4u/trades.csv _out_4u/trades_A.csv

      - name: Clean BETWEEN runs
        shell: bash
        run: |
          set -euo pipefail
          rm -f _out_4u/trades.csv || true

      - name: Patch TTL in config (B)
        shell: bash
        env:
          TTL: ${{ github.event.inputs.TTL_B }}
        run: |
          set -euo pipefail
          CONF=tmp/trade/conf/config.effective.yml
          python - <<'PY'
          import os, yaml, pathlib
          p = pathlib.Path("tmp/trade/conf/config.effective.yml")
          cfg = {}
          if p.exists():
              try:
                  import yaml as _y; cfg = _y.safe_load(p.read_text()) or {}
              except Exception:
                  cfg = {}
          cfg.setdefault("exit",{})
          cfg["exit"]["ttl"] = int(os.environ.get("TTL","0"))
          p.write_text(yaml.safe_dump(cfg, sort_keys=False))
          print("[patchB] ttl ->", cfg["exit"]["ttl"])
          PY

      - name: Run B (TTL=B)
        shell: bash
        run: |
          set -euo pipefail
          python -u run_engine.py
          test -f _out_4u/trades.csv
          cp -f _out_4u/trades.csv _out_4u/trades_B.csv

      - name: Assert A != B (TTL effect)
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PY'
          import hashlib, pathlib, sys
          a = pathlib.Path("_out_4u/trades_A.csv")
          b = pathlib.Path("_out_4u/trades_B.csv")
          if not (a.exists() and b.exists()):
              print("MISSING trades_A.csv or trades_B.csv"); sys.exit(2)
          H = lambda p: hashlib.sha256(p.read_bytes()).hexdigest()
          sha = (H(a), H(b))
          print("SHA_A", sha[0]); print("SHA_B", sha[1])
          if sha[0] == sha[1]:
              print("Error: Exit/TTL not applied (A==B)"); sys.exit(3)
          PY

      - name: Upload artifacts (pinned SHA)
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: exit_ttl_abtest_outputs
          path: |
            _out_4u/CSV_PATH.txt
            _out_4u/trades_A.csv
            _out_4u/trades_B.csv
