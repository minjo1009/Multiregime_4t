name: Exit/TTL A-B (param v2, pinned)

on:
  workflow_dispatch:
    inputs:
      CODE_PACK:
        description: "Root code pack zip in repo (e.g., trade_v1.1.4.zip)"
        required: true
        default: "trade_v1.1.4.zip"
      DATA_ZIP:
        description: "Optional data zip path in repo (unzips to tmp/data)"
        required: false
        default: ""
      CSV_GLOB:
        description: "CSV glob under tmp/data (leave empty to auto-pick 1st CSV)"
        required: false
        default: ""

permissions:
  contents: read

jobs:
  abtest:
    name: abtest
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (pinned)
        uses: actions/checkout@11bd71901bbe5b1630b4b23b5b2ac60a8a6e3f2

      - name: Setup Python 3.11 (pinned)
        uses: actions/setup-python@a26af69be951a213e376a39fc6824e9f5b089bc5
        with:
          python-version: '3.11'

      - name: Prepare workspace
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p tmp/trade tmp/data _out_4u
          # unzip code pack
          if [ ! -f "${{ github.workspace }}/${{ inputs.CODE_PACK }}" ]; then
            echo "::error title=Missing code pack::${{ inputs.CODE_PACK }} not found at repo root"
            exit 1
          fi
          unzip -oq "${{ github.workspace }}/${{ inputs.CODE_PACK }}" -d tmp/trade
          # optional data zip
          if [ -n "${{ inputs.DATA_ZIP }}" ] && [ -f "${{ github.workspace }}/${{ inputs.DATA_ZIP }}" ]; then
            unzip -oq "${{ github.workspace }}/${{ inputs.DATA_ZIP }}" -d tmp/data || true
          fi
          echo "Workspace ready"; ls -al tmp/trade | head -n 50

      - name: Create run_engine.py (bridge & normalizer)
        shell: bash
        run: |
          set -Eeuo pipefail
          python - <<'PY'
          import os, sys, glob, runpy, json
          from pathlib import Path
          try:
              import yaml
          except Exception:
              os.system("python -m pip -q install pyyaml >/dev/null 2>&1")
              import yaml

          ROOT = Path("tmp/trade")
          CFG_IN = ROOT/"conf"/"config.yml"
          CFG_OUT = ROOT/"conf"/"config.effective.yml"
          OUT_DIR = Path("_out_4u"); OUT_DIR.mkdir(exist_ok=True, parents=True)

          def select_csv():
              # 1) respect CSV_GLOB if user gave one
              pat = os.environ.get("CSV_GLOB", "").strip()
              if pat:
                  hits = sorted(Path("tmp/data").glob(pat))
              else:
                  hits = sorted(Path("tmp/data").glob("**/*.csv"))
              if not hits:
                  # also look under repo-root data if present
                  hits = sorted(Path("data").glob("**/*.csv"))
              if not hits:
                  raise FileNotFoundError("No CSV found under tmp/data or data")
              return str(hits[0])

          def build_config(exit_ttl:int):
              cfg = {}
              if CFG_IN.exists():
                  cfg = yaml.safe_load(CFG_IN.read_text()) or {}
              cfg.setdefault("exit", {})
              cfg["exit"]["ttl"] = int(exit_ttl)
              CFG_OUT.parent.mkdir(parents=True, exist_ok=True)
              CFG_OUT.write_text(yaml.safe_dump(cfg, sort_keys=False))
              return CFG_OUT

          def find_entry():
              cand = [
                  ROOT/"run_4u.py",
                  ROOT/"backtest"/"engine.py",
                  ROOT/"backtest"/"runner.py",
              ]
              for c in cand:
                  if c.exists(): 
                      return c
              raise FileNotFoundError("No engine entry found (run_4u.py / backtest/engine.py / backtest/runner.py)")

          # emit a tiny runner to standardize calling convention
          Path("run_engine.py").write_text(
              "\n".join([
                  "import os,sys,runpy,glob",
                  "from pathlib import Path",
                  "DATA = os.environ.get('DATA_PATH')",
                  "if not DATA:",
                  "  PAT=os.environ.get('CSV_GLOB','').strip() or '**/*.csv'",
                  "  hits=sorted(Path('tmp/data').glob(PAT)) or sorted(Path('data').glob(PAT))",
                  "  DATA=str(hits[0]) if hits else None",
                  "if not DATA: raise FileNotFoundError('No CSV found under tmp/data or data')",
                  "ENTRY = os.environ.get('ENTRY') or ''",
                  "if not ENTRY or not Path(ENTRY).exists():",
                  "  for p in ['tmp/trade/run_4u.py','tmp/trade/backtest/engine.py','tmp/trade/backtest/runner.py']:",
                  "    if Path(p).exists(): ENTRY=p; break",
                  "if not ENTRY: raise FileNotFoundError('No engine entry found')",
                  "CFG = os.environ.get('CFG','tmp/trade/conf/config.effective.yml')",
                  "OUT = os.environ.get('OUT_DIR','_out_4u')",
                  "Path(OUT).mkdir(exist_ok=True, parents=True)",
                  "sys.argv=[ENTRY,'--data_path',DATA,'--config',CFG,'--out_dir',OUT]",
                  "runpy.run_path(ENTRY, run_name='__main__')",
              ])
          )
          # pre-flight build once for TTL=0 just to validate I/O
          data = select_csv()
          cfg = build_config(0)
          entry = find_entry()
          print(f"[bridge] csv={data}\n[bridge] cfg={cfg}\n[bridge] entry={entry}")
          PY

      - name: Run A (TTL=1)
        shell: bash
        env:
          CSV_GLOB: ${{ inputs.CSV_GLOB }}
          TTL: "1"
        run: |
          set -Eeuo pipefail
          python - <<'PY'
          import os, subprocess, sys, json
          from pathlib import Path
          import yaml
          # update ttl
          cfgp = Path("tmp/trade/conf/config.effective.yml")
          cfg = yaml.safe_load(cfgp.read_text()) if cfgp.exists() else {}
          cfg.setdefault("exit", {})["ttl"] = 1
          cfgp.write_text(yaml.safe_dump(cfg, sort_keys=False))
          env = dict(os.environ); env.update({"CFG": str(cfgp)})
          r = subprocess.run([sys.executable, "run_engine.py"], env=env, check=False)
          sys.exit(r.returncode)
          PY
          test -f _out_4u/trades.csv && sha256sum _out_4u/trades.csv | tee _out_4u/trades_A.sha256 || true

      - name: Clean BETWEEN runs
        run: |
          rm -f _out_4u/trades.csv || true

      - name: Run B (TTL=5000)
        shell: bash
        env:
          CSV_GLOB: ${{ inputs.CSV_GLOB }}
          TTL: "5000"
        run: |
          set -Eeuo pipefail
          python - <<'PY'
          import os, subprocess, sys, json
          from pathlib import Path
          import yaml
          # update ttl
          cfgp = Path("tmp/trade/conf/config.effective.yml")
          cfg = yaml.safe_load(cfgp.read_text()) if cfgp.exists() else {}
          cfg.setdefault("exit", {})["ttl"] = 5000
          cfgp.write_text(yaml.safe_dump(cfg, sort_keys=False))
          env = dict(os.environ); env.update({"CFG": str(cfgp)})
          r = subprocess.run([sys.executable, "run_engine.py"], env=env, check=False)
          sys.exit(r.returncode)
          PY
          test -f _out_4u/trades.csv && sha256sum _out_4u/trades.csv | tee _out_4u/trades_B.sha256 || true

      - name: Assert A != B (TTL effect)
        if: always()
        shell: bash
        run: |
          set -Eeuo pipefail
          if [ ! -f _out_4u/trades_A.sha256 ] || [ ! -f _out_4u/trades_B.sha256 ]; then
            echo "MISSING one or both trade hashes"; exit 2
          fi
          A=$(cut -d' ' -f1 _out_4u/trades_A.sha256)
          B=$(cut -d' ' -f1 _out_4u/trades_B.sha256)
          echo "SHA_A=$A"; echo "SHA_B=$B"
          if [ "$A" = "$B" ]; then
            echo "::error title=Exit/TTL not applied::A==B"; exit 3
          fi

      - name: Upload artifacts (pinned)
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: exit_ttl_abtest_outputs
          path: |
            _out_4u/trades*.sha256
            _out_4u/trades.csv
          if-no-files-found: warn
