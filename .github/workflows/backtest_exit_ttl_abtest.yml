name: Exit/TTL A-B test (core-fixed)

on:
  workflow_dispatch:

defaults:
  run:
    shell: bash

jobs:
  abtest:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (pinned SHA)
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683

      - name: Setup Python 3.11 (pinned SHA)
        uses: actions/setup-python@a26af69be951a213e376a39fc6824e9f5b089bc5
        with:
          python-version: '3.11'

      - name: Prepare workspace
        run: |
          set -Eeuo pipefail
          mkdir -p tmp/trade/conf tmp/data _out_4u
          python -m pip install --upgrade pip
          python -m pip install --no-cache-dir pyyaml
          echo "Workspace ready."
          # If there is no CSV yet, list current tree (for debugging)
          echo "--- repo tree (depth 2) ---"
          find . -maxdepth 2 -type f | sed 's/^/  /' || true

      - name: Create run_engine.py (core v7)
        run: |
          set -Eeuo pipefail
          cat > run_engine.py <<'PY'
          import os, sys, glob, json, shutil, runpy, hashlib, textwrap, pathlib
          from pathlib import Path
          # Optional: use YAML overlay if available
          try:
              import yaml  # installed in workflow
          except Exception:
              yaml = None

          ROOT = Path(".")
          OUT = ROOT / "_out_4u"
          OUT.mkdir(parents=True, exist_ok=True)

          def select_csv():
              pat = os.environ.get("CSV_GLOB", "tmp/data/**/*.csv")
              paths = [Path(p) for p in glob.glob(pat, recursive=True)]
              paths = [p for p in paths if p.is_file()]
              if not paths:
                  raise FileNotFoundError(f"No CSV found with pattern: {pat}")
              # Prefer ETHUSDT if present
              for p in paths:
                  if "ETHUSDT" in p.name.upper():
                      return str(p)
              return str(paths[0])

          def write_effective_cfg(base_cfg_path: Path, ttl_val: int):
              eff = Path("tmp/trade/conf/config.effective.yml")
              if yaml and base_cfg_path.exists():
                  try:
                      base = yaml.safe_load(base_cfg_path.read_text()) or {}
                  except Exception:
                      base = {}
              else:
                  base = {}
              # ensure sections
              base.setdefault("trade", {})
              base.setdefault("exit", {})
              # overlay values from base + env
              # keep existing trade.tp/sl/hold_bars if present
              # but force exit.ttl from env (or config.yml if set)
              ttl_from_env = os.environ.get("TTL")
              if ttl_from_env is not None:
                  try:
                      ttl_val = int(ttl_from_env)
                  except Exception:
                      pass
              base["exit"]["ttl"] = ttl_val
              eff.write_text(yaml.safe_dump(base, sort_keys=False) if yaml else "")
              print(f"[exit_bridge] wrote {eff}")
              return str(eff)

          def find_runner():
              # Priority: tmp/trade/run_4u.py -> tmp/trade/runner.py -> backtest/runner.py -> backtest/engine.py
              cands = [
                  Path("tmp/trade/run_4u.py"),
                  Path("tmp/trade/runner.py"),
                  Path("backtest/runner.py"),
                  Path("backtest/engine.py"),
              ]
              for c in cands:
                  if c.exists():
                      return c
              raise FileNotFoundError("No engine entry found (run_4u.py or backtest/runner.py or backtest/engine.py)")

          def run_once():
              data_path = select_csv()
              base_cfg = Path("tmp/trade/conf/config.yml")
              # choose a TTL default from config (if any), else env, else 0
              ttl_default = int(os.environ.get("TTL", "0"))
              eff_cfg = write_effective_cfg(base_cfg, ttl_default)

              runner = find_runner()
              # Always pass args to unify interfaces
              argv = [str(runner),
                      "--data_path", data_path,
                      "--config", eff_cfg,
                      "--out_dir", "_out_4u"]
              sys.argv = argv
              print(f"[RUNNER] {runner} argv={argv[1:]}")

              # Try to run; if engine.py uses import style, still works
              runpy.run_path(str(runner), run_name="__main__")

              # Normalize trades.csv (search then copy)
              found = None
              for p in OUT.rglob("trades.csv"):
                  found = p
                  break
              if not found:
                  # search project-wide (some engines write elsewhere)
                  for p in Path(".").rglob("trades.csv"):
                      found = p
                      break
              if not found:
                  raise FileNotFoundError("trades.csv not produced by engine")
              target = OUT / "trades.csv"
              if found.resolve() != target.resolve():
                  target.parent.mkdir(parents=True, exist_ok=True)
                  shutil.copyfile(str(found), str(target))
              print(f"[collect] trades.csv -> {target}")
              return True

          if __name__ == "__main__":
              ok = run_once()
              print(json.dumps({"ok": bool(ok)}))
          PY
          python -m pyflakes run_engine.py || true

      - name: Run A (ttl=1)
        env:
          TTL: "1"
        run: |
          set -Eeuo pipefail
          # Config A
          cat > tmp/trade/conf/config.yml <<'YML'
          trade:
            tp_pct: 0.010
            sl_pct: 0.005
            hold_bars: 1
            be_on: false
            trail_on: false
          exit:
            ttl: 1
          YML
          python -u run_engine.py
          mv -f _out_4u/trades.csv _out_4u/trades_A.csv

      - name: Run B (ttl=5000)
        env:
          TTL: "5000"
        run: |
          set -Eeuo pipefail
          # Config B
          cat > tmp/trade/conf/config.yml <<'YML'
          trade:
            tp_pct: 0.010
            sl_pct: 0.005
            hold_bars: 5000
            be_on: false
            trail_on: false
          exit:
            ttl: 5000
          YML
          python -u run_engine.py
          mv -f _out_4u/trades.csv _out_4u/trades_B.csv

      - name: Assert A != B
        run: |
          set -Eeuo pipefail
          python - <<'PY'
          import hashlib, sys
          def sha(p):
              h = hashlib.sha256()
              with open(p,'rb') as f:
                  while True:
                      b=f.read(1024*1024)
                      if not b: break
                      h.update(b)
              return h.hexdigest()
          a = sha("_out_4u/trades_A.csv")
          b = sha("_out_4u/trades_B.csv")
          print("SHA_A", a)
          print("SHA_B", b)
          if a == b:
              print("Error: Exit/TTL not applied (A==B)")
              sys.exit(3)
          PY

      - name: Upload artifacts (pinned SHA)
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: exit_ttl_abtest_outputs
          path: |
            _out_4u/trades_A.csv
            _out_4u/trades_B.csv
            tmp/trade/conf/config.yml
            tmp/trade/conf/config.effective.yml
