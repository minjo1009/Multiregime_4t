name: Exit/TTL A-B (param v2, pinned)

on:
  workflow_dispatch:
    inputs:
      CODEPACK_ZIP:
        description: "Path to code pack zip (in repo root, e.g. trade_v1.1.4.zip)"
        required: true
        default: "trade_v1.1.4.zip"
      CSV_GLOB:
        description: "Glob for CSV under data/ or tmp/data (e.g. **/*ETHUSDT*1min*2020*2025*.csv)"
        required: true
        default: "**/*ETHUSDT*1min*2020*2025*.csv"
      TTL_A:
        description: "TTL for run A"
        required: true
        default: "1"
      TTL_B:
        description: "TTL for run B"
        required: true
        default: "5000"

permissions:
  contents: read

jobs:
  abtest:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (pinned)
        uses: actions/checkout@11bd71901bbe5b1630b4b23b5b2ac60a8a6e3f2

      - name: Setup Python 3.11 (pinned)
        uses: actions/setup-python@a26af69be951a213e376a39fc6824e9f5b089bc5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install pyyaml

      - name: Prepare workspace
        env:
          CODEPACK_ZIP: ${{ github.event.inputs.CODEPACK_ZIP }}
          CSV_GLOB: ${{ github.event.inputs.CSV_GLOB }}
        run: |
          set -euo pipefail
          mkdir -p tmp/trade tmp/data _out_4u
          echo "[prep] unzip ${CODEPACK_ZIP} -> tmp/trade"
          unzip -o "${CODEPACK_ZIP}" -d tmp/trade >/dev/null
          echo "[prep] search CSV with glob: ${CSV_GLOB}"
          SEL=$(python -c "import glob,os,sys,pathlib; pat=os.environ.get('CSV_GLOB','**/*.csv'); p=pathlib.Path; c=sorted(glob.glob(str(p('tmp/data')/pat), recursive=True)); d=sorted(glob.glob(str(p('data')/pat), recursive=True)); print((c or d or [''])[0])")
          if [ -z "${SEL}" ]; then
            echo "No CSV found under tmp/data or data"
            exit 1
          fi
          echo "${SEL}" > _out_4u/CSV_PATH.txt
          echo "[prep] CSV selected: ${SEL}"

      - name: Create run_engine.py (bridge & normalizer)
        run: |
          set -euo pipefail
          cat > run_engine.py <<'PY'
import os, sys, glob, shutil, inspect, argparse
from pathlib import Path
import yaml

def load_csv_path():
    p = Path("_out_4u/CSV_PATH.txt")
    if not p.exists():
        raise FileNotFoundError("CSV_PATH.txt missing")
    return p.read_text().strip()

def ensure_config_with_ttl(ttl:int)->Path:
    eff = Path("tmp/trade/conf/config.effective.yml")
    eff.parent.mkdir(parents=True, exist_ok=True)
    cfg = {}
    if eff.exists():
        try:
            cfg = yaml.safe_load(eff.read_text()) or {}
        except Exception:
            cfg = {}
    cfg.setdefault("exit", {})["ttl"] = int(ttl)
    eff.write_text(yaml.safe_dump(cfg, sort_keys=False))
    print(f"[bridge] wrote {eff} with exit.ttl={ttl}")
    return eff

def resolve_engine():
    sys.path.insert(0, "tmp/trade")
    candidates = [
        ("backtest.engine", "run_backtest"),
        ("backtest.engine", "main"),
        ("backtest.engine", "run"),
        ("backtest.runner", "main"),
    ]
    for mod, attr in candidates:
        try:
            m = __import__(mod, fromlist=[attr])
            fn = getattr(m, attr)
            print(f"[engine] using {mod}.{attr}")
            return fn
        except Exception:
            continue
    raise FileNotFoundError("No engine entry found (run_4u.py or backtest/engine.py)")

def invoke(fn, data_path:str, config_path:str, out_dir:str):
    try:
        import inspect
        sig = inspect.signature(fn)
        params = set(sig.parameters.keys())
        kwargs = {}
        if "data_path" in params: kwargs["data_path"] = data_path
        if "config" in params: kwargs["config"] = config_path
        if "config_path" in params: kwargs["config_path"] = config_path
        if "out_dir" in params: kwargs["out_dir"] = out_dir
        if kwargs:
            return fn(**kwargs)
        else:
            return fn(data_path, config_path, out_dir)
    except TypeError:
        return fn(data_path, config_path, out_dir)

def normalize_trades(out_path:Path):
    if out_path.exists():
        return True
    cands = sorted(glob.glob("tmp/trade/**/trades*.csv", recursive=True))
    if cands:
        Path(out_path.parent).mkdir(parents=True, exist_ok=True)
        shutil.copy2(cands[0], out_path)
        print(f"[bridge] copied {cands[0]} -> {out_path}")
        return True
    return False

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--ttl", type=int, required=True)
    ap.add_argument("--out", type=str, required=True)
    args = ap.parse_args()

    data_path = load_csv_path()
    eff = ensure_config_with_ttl(args.ttl)
    out_dir = str(Path("_out_4u"))

    fn = resolve_engine()
    invoke(fn, data_path=data_path, config_path=str(eff), out_dir=out_dir)

    out_csv = Path(args.out)
    if not normalize_trades(out_csv):
        raise FileNotFoundError("trades.csv not produced by engine")

if __name__ == "__main__":
    main()
PY

      - name: Run A (TTL=${{ github.event.inputs.TTL_A }})
        env:
          TTL: ${{ github.event.inputs.TTL_A }}
        run: |
          set -euo pipefail
          python run_engine.py --ttl "${TTL}" --out "_out_4u/trades_A.csv"

      - name: Clean BETWEEN runs
        run: |
          rm -f _out_4u/trades.csv || true

      - name: Run B (TTL=${{ github.event.inputs.TTL_B }})
        env:
          TTL: ${{ github.event.inputs.TTL_B }}
        run: |
          set -euo pipefail
          python run_engine.py --ttl "${TTL}" --out "_out_4u/trades_B.csv"

      - name: Assert A != B (TTL effect)
        run: |
          python - <<'PY'
import hashlib, pathlib, sys
def sha(p):
    d=hashlib.sha256(); d.update(pathlib.Path(p).read_bytes()); return d.hexdigest()
A="_out_4u/trades_A.csv"; B="_out_4u/trades_B.csv"
try:
    sa, sb = sha(A), sha(B)
    print("SHA_A", sa); print("SHA_B", sb)
    if sa == sb:
        print("Error: Exit/TTL not applied (A==B)"); raise SystemExit(3)
except FileNotFoundError as e:
    print("MISSING", str(e).split("'")[1]); raise SystemExit(2)
PY

      - name: Upload artifacts (pinned SHA)
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: exit_ttl_abtest_outputs
          path: |
            _out_4u/**
            run_engine.py
            _out_4u/CSV_PATH.txt
