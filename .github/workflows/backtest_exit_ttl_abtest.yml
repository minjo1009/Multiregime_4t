name: Exit/TTL A-B (param v2, pinned)

on:
  workflow_dispatch:
    inputs:
      CODEPACK_ZIP:
        description: "Path to code pack zip (in repo root). Example: trade_v1.1.4.zip"
        required: true
        default: "trade_v1.1.4.zip"
      CSV_GLOB:
        description: "Glob for CSV under data/ or tmp/data/. Example: '**/*ETHUSDT*1min*2020*2025*.csv'"
        required: true
        default: "**/*.csv"
      TTL_A:
        description: "TTL for run A"
        required: true
        default: "1"
      TTL_B:
        description: "TTL for run B"
        required: true
        default: "5000"

jobs:
  abtest:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Checkout (pinned SHA)
        uses: actions/checkout@11bd71901bbe5b1630b4b23b5b2ac60a8a6e3f2

      - name: Setup Python 3.11 (pinned SHA)
        uses: actions/setup-python@a26af69be951a213e376a39fc6824e9f5b089bc5
        with:
          python-version: '3.11'

      - name: Prepare workspace
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p tmp/trade tmp/data _out_4u
          test -f "${{ github.event.inputs.CODEPACK_ZIP }}" || { echo "Missing codepack zip: ${{ github.event.inputs.CODEPACK_ZIP }}"; exit 2; }
          unzip -q "${{ github.event.inputs.CODEPACK_ZIP }}" -d tmp/trade

      - name: Create run_engine.py (bridge & normalizer)
        shell: bash
        run: |
          set -euo pipefail
          cat > run_engine.py <<'PY'
          import argparse, os, sys, glob, shutil, hashlib, json
          from pathlib import Path
          try:
              import yaml  # type: ignore
          except Exception:
              print("[bridge] installing pyyaml...")
              import subprocess; subprocess.check_call([sys.executable, "-m", "pip", "install", "pyyaml"])
              import yaml  # type: ignore

          ROOT = Path.cwd()
          TRADE = ROOT/"tmp/trade"
          CONF_DIR = TRADE/"conf"
          EFFECTIVE = CONF_DIR/"config.effective.yml"
          OUT = ROOT/"_out_4u"
          OUT.mkdir(exist_ok=True, parents=True)

          def select_csv(patterns):
              # search under tmp/data then data
              candidates = []
              for base in [ROOT/"tmp/data", ROOT/"data"]:
                  for pat in patterns:
                      candidates.extend(sorted(base.rglob(pat)))
              if not candidates:
                  raise FileNotFoundError("No CSV found under tmp/data or data")
              return candidates[0]

          def overlay_config(ttl:int):
              CONF_DIR.mkdir(parents=True, exist_ok=True)
              base_cfg = {}
              base_yml = TRADE/"conf"/"config.yml"
              if base_yml.exists():
                  try:
                      base_cfg = yaml.safe_load(base_yml.read_text()) or {}
                  except Exception as e:
                      print("[bridge] WARN: base config read failed:", e)
              # ensure nested keys
              def ensure(d,k): d.setdefault(k, {}); return d[k]
              exit_cfg = ensure(base_cfg, "exit")
              exit_cfg["ttl"] = int(ttl)
              # normalize out dir (if config uses it)
              ensure(base_cfg, "io")["out_dir"] = str(OUT)
              EFFECTIVE.write_text(yaml.safe_dump(base_cfg, sort_keys=False))
              print("[bridge] wrote", EFFECTIVE)

          def sha256(p: Path):
              h = hashlib.sha256()
              with p.open("rb") as f:
                  for chunk in iter(lambda: f.read(1<<20), b""):
                      h.update(chunk)
              return h.hexdigest()

          def try_run(csv_path: Path):
              # Try run_4u.py first
              sys.path[:0] = [str(TRADE), str(TRADE/"backtest")]
              argv = ["--data_path", str(csv_path), "--config", str(EFFECTIVE), "--out_dir", str(OUT)]
              tried = []

              # 1) tmp/trade/run_4u.py (argparse expected)
              p = TRADE/"run_4u.py"
              if p.exists():
                  print("[engine] using", p)
                  tried.append(str(p))
                  import runpy
                  sys.argv = [str(p)] + argv
                  runpy.run_path(str(p), run_name="__main__")
                  return True, tried

              # 2) tmp/trade/backtest/engine.py (functions: run_backtest or main)
              p = TRADE/"backtest"/"engine.py"
              if p.exists():
                  print("[engine] using", p)
                  tried.append(str(p))
                  import importlib.util
                  spec = importlib.util.spec_from_file_location("bk_engine", str(p))
                  m = importlib.util.module_from_spec(spec); assert spec and spec.loader; spec.loader.exec_module(m)  # type: ignore
                  if hasattr(m, "run_backtest"):
                      m.run_backtest(str(csv_path), str(EFFECTIVE), str(OUT))  # type: ignore
                      return True, tried
                  if hasattr(m, "main"):
                      m.main(data_path=str(csv_path), config_path=str(EFFECTIVE), out_dir=str(OUT))  # type: ignore
                      return True, tried

              # 3) tmp/trade/backtest/runner.py (main / run_backtest)
              p = TRADE/"backtest"/"runner.py"
              if p.exists():
                  print("[engine] using", p)
                  tried.append(str(p))
                  import importlib.util
                  spec = importlib.util.spec_from_file_location("bk_runner", str(p))
                  m = importlib.util.module_from_spec(spec); assert spec and spec.loader; spec.loader.exec_module(m)  # type: ignore
                  if hasattr(m, "run_backtest"):
                      m.run_backtest(str(csv_path), str(EFFECTIVE), str(OUT))  # type: ignore
                      return True, tried
                  if hasattr(m, "main"):
                      m.main(data_path=str(csv_path), config_path=str(EFFECTIVE), out_dir=str(OUT))  # type: ignore
                      return True, tried

              return False, tried

          def normalize_output():
              # Find any plausible trades csv and copy to _out_4u/trades.csv
              candidates = []
              for pat in ["trades.csv", "*trades*.csv", "results.csv"]:
                  candidates += [Path(p) for p in glob.glob(str(OUT/pat))]
                  candidates += [Path(p) for p in glob.glob(str(TRADE/"**"/pat), recursive=True)]
              for c in candidates:
                  if c.exists() and c.is_file():
                      shutil.copy2(c, OUT/"trades.csv")
                      return OUT/"trades.csv"
              # as last resort, if a json summary exists with trades path, we could parse it (skipped here)
              return None

          def main():
              ap = argparse.ArgumentParser()
              ap.add_argument("--ttl", type=int, required=True)
              ap.add_argument("--csv_glob", type=str, required=True)
              args = ap.parse_args()

              patterns = [s for s in args.csv_glob.split("|")] if "|" in args.csv_glob else [args.csv_glob]
              csv_path = select_csv(patterns)
              print("[bridge] selected CSV:", csv_path)

              overlay_config(args.ttl)
              ok, tried = try_run(csv_path)
              if not ok:
                  print("[bridge] ERROR: no compatible engine entry. tried:", tried, file=sys.stderr)
                  sys.exit(2)

              out = normalize_output()
              if not out or not out.exists():
                  print("[bridge] ERROR: trades.csv not produced", file=sys.stderr)
                  sys.exit(2)

              h = sha256(out)
              (out.parent/"trades.sha256").write_text(h + "\n")
              print("[bridge] trades sha256:", h)
              print(json.dumps({"csv": str(out), "sha256": h}))

          if __name__ == "__main__":
              main()
          PY

      - name: Run A (TTL=${{ github.event.inputs.TTL_A }})
        shell: bash
        env:
          CSV_GLOB: ${{ github.event.inputs.CSV_GLOB }}
          TTL_VAL: ${{ github.event.inputs.TTL_A }}
        run: |
          set -euo pipefail
          python run_engine.py --ttl "${TTL_VAL}" --csv_glob "${CSV_GLOB}"
          mv -f _out_4u/trades.csv _out_4u/trades_A.csv
          mv -f _out_4u/trades.sha256 _out_4u/trades.A.sha256

      - name: Clean BETWEEN runs
        shell: bash
        run: |
          rm -f _out_4u/trades.csv _out_4u/trades.sha256 || true

      - name: Run B (TTL=${{ github.event.inputs.TTL_B }})
        shell: bash
        env:
          CSV_GLOB: ${{ github.event.inputs.CSV_GLOB }}
          TTL_VAL: ${{ github.event.inputs.TTL_B }}
        run: |
          set -euo pipefail
          python run_engine.py --ttl "${TTL_VAL}" --csv_glob "${CSV_GLOB}"
          mv -f _out_4u/trades.csv _out_4u/trades_B.csv
          mv -f _out_4u/trades.sha256 _out_4u/trades.B.sha256

      - name: Assert A != B (TTL effect)
        shell: bash
        run: |
          set -euo pipefail
          A="$(cat _out_4u/trades.A.sha256 || true)"
          B="$(cat _out_4u/trades.B.sha256 || true)"
          echo "SHA_A ${A}"
          echo "SHA_B ${B}"
          if [[ -z "$A" || -z "$B" ]]; then
            echo "Error: missing SHA files"; exit 2;
          fi
          if [[ "$A" == "$B" ]]; then
            echo "Error: Exit/TTL not applied (A==B)"; exit 3;
          fi
          echo "OK: TTL affected outputs"

      - name: Upload artifacts (pinned SHA)
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: exit_ttl_abtest_outputs
          path: |
            _out_4u/trades_A.csv
            _out_4u/trades_B.csv
            _out_4u/trades.A.sha256
            _out_4u/trades.B.sha256
            tmp/trade/conf/config.effective.yml
