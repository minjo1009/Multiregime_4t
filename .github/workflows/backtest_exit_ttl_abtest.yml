name: Exit/TTL A-B (param v2, pinned)

on:
  workflow_dispatch:
    inputs:
      CODEPACK_ZIP:
        description: "Path to code pack zip (repo-root relative)"
        required: true
        default: "trade_v1.1.4.zip"
      CSV_GLOB:
        description: "Glob for CSV under tmp/data/ (after unzip)"
        required: true
        default: "**/*.csv"
      TTL_A:
        description: "TTL for run A"
        required: true
        default: "1"
      TTL_B:
        description: "TTL for run B"
        required: true
        default: "5000"

jobs:
  abtest:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (pinned)
        uses: actions/checkout@11bd71901b5b5b1630b4b23b5b2ac60a8a6e3f2

      - name: Setup Python 3.11 (pinned)
        uses: actions/setup-python@a26af69be951a213e376a39fc6824e9f5b089bc5
        with:
          python-version: '3.11'

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install pyyaml

      - name: Prepare workspace
        env:
          CODEPACK_ZIP: ${{ github.event.inputs.CODEPACK_ZIP }}
          CSV_GLOB: ${{ github.event.inputs.CSV_GLOB }}
        run: |
          set -euo pipefail
          mkdir -p tmp/trade tmp/data _out_4u
          echo "[prep] unzip ${CODEPACK_ZIP} -> tmp/trade"
          unzip -o "${CODEPACK_ZIP}" -d tmp/trade >/dev/null
          echo "[prep] search CSV with glob: ${CSV_GLOB}"
          SEL=$(python - <<'PY'
          import glob, os
          pat=os.environ.get('CSV_GLOB',"**/*.csv")
          c=sorted(glob.glob("tmp/data/"+pat, recursive=True))
          print(c[0] if c else "")
          PY
          )
          if [ -z "${SEL}" ]; then
            echo "No CSV found under tmp/data"
            exit 1
          fi
          echo "${SEL}" > _out_4u/CSV_PATH.txt
          echo "[prep] CSV selected: ${SEL}"

      - name: Create run_engine.py (bridge & normalizer)
        run: |
          set -euo pipefail
          cat > run_engine.py <<'PY'
          import os, sys, glob, shutil, argparse, yaml, importlib
          from pathlib import Path

          def load_csv_path():
            p = Path("_out_4u/CSV_PATH.txt")
            if not p.exists():
              raise FileNotFoundError("CSV_PATH.txt missing")
            return p.read_text().strip()

          def ensure_config_with_ttl(ttl:int)->Path:
            eff = Path("tmp/trade/conf/config.effective.yml")
            eff.parent.mkdir(parents=True, exist_ok=True)
            cfg = {}
            if eff.exists():
              try:
                import yaml as _yaml
                cfg = _yaml.safe_load(eff.read_text()) or {}
              except Exception:
                cfg = {}
            exit_cfg = cfg.get("exit", {})
            if not isinstance(exit_cfg, dict):
              exit_cfg = {}
            exit_cfg["ttl"] = int(ttl)
            cfg["exit"] = exit_cfg
            eff.write_text(yaml.safe_dump(cfg, sort_keys=False))
            return eff

          def call_engine(data_path:str, config_path:str, out_dir:str)->bool:
            # candidate modules and preferred entry names
            candidates=[
              ("tmp/trade/run_4u.py",      ["run_backtest", "main"]),
              ("tmp/trade/backtest/runner.py", ["main", "run_backtest"]),
              ("tmp/trade/backtest/engine.py", ["main", "run_backtest"]),
            ]
            sys.path.insert(0, "tmp/trade")
            for mod_path, names in candidates:
              p = Path(mod_path)
              if not p.exists():
                continue
              mod_name = ".".join(Path(mod_path).with_suffix("").parts[1:])  # strip tmp/trade/
              m = importlib.import_module(mod_name)
              f = None
              for nm in names:
                f = getattr(m, nm, None)
                if f: break
              if not f:
                continue
              # try keyword, then positional, then no-arg
              try:
                rv = f(data_path=data_path, config_path=config_path, out_dir=out_dir)
              except TypeError:
                try:
                  rv = f(data_path, config_path, out_dir)
                except TypeError:
                  rv = f()
              return True
            raise FileNotFoundError("No engine entry found (run_4u.py / backtest/runner.py / backtest/engine.py)")

          def main(ttl:int):
            data_path = load_csv_path()
            config = str(ensure_config_with_ttl(ttl))
            out_dir = "_out_4u"
            ok = call_engine(data_path, config, out_dir)
            # normalize trades.csv
            cand = sorted(glob.glob("_out_4u/trades*.csv")) + sorted(glob.glob("**/trades*.csv", recursive=True))
            if cand:
              Path("_out_4u").mkdir(exist_ok=True)
              shutil.copyfile(cand[0], "_out_4u/trades.csv")
            return ok

          if __name__ == "__main__":
            ap = argparse.ArgumentParser()
            ap.add_argument("--ttl", type=int, required=True)
            args = ap.parse_args()
            sys.exit(0 if main(args.ttl) else 1)
          PY

      - name: Run A (TTL=${{ github.event.inputs.TTL_A }})
        env:
          TTL: ${{ github.event.inputs.TTL_A }}
        run: |
          set -euo pipefail
          python run_engine.py --ttl="${TTL}"

      - name: Clean BETWEEN runs
        run: |
          rm -f _out_4u/trades.csv

      - name: Run B (TTL=${{ github.event.inputs.TTL_B }})
        env:
          TTL: ${{ github.event.inputs.TTL_B }}
        run: |
          set -euo pipefail
          python run_engine.py --ttl="${TTL}"

      - name: Assert A != B (TTL effect)
        run: |
          set -euo pipefail
          python - <<'PY'
          import hashlib, pathlib, sys
          p=pathlib.Path("_out_4u/trades.csv")
          if not p.exists():
            print("MISSING _out_4u/trades.csv"); sys.exit(2)
          data=p.read_bytes()
          print("SHA", hashlib.sha256(data).hexdigest())
          PY

      - name: Upload artifacts (pinned SHA)
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: exit_ttl_abtest_outputs
          path: |
            _out_4u/**
            run_engine.py
