<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Trade4V Viewer Pro v2.4 (Schema v1)</title>
  <style>
    :root { --bg:#0b1220; --panel:#0e1628; --card:#111827; --muted:#9ca3af; --fg:#e5e7eb; --accent:#60a5fa; --good:#10b981; --bad:#ef4444; }
    html, body { height: 100%; background: var(--bg); color: var(--fg); font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .wrap { display:flex; height:100%; }
    .side { width:380px; background: var(--panel); padding:16px; border-right:1px solid #1f2937; overflow:auto; }
    .main { flex:1; display:flex; flex-direction:column; gap:12px; padding:16px; overflow:auto; }
    h1 { margin:0 0 12px; font-size:18px; font-weight:600; }
    .section { margin-bottom:16px; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .btn { background:#1f2937; border:1px solid #374151; color:#e5e7eb; border-radius:8px; padding:8px 10px; cursor:pointer; }
    .btn:hover { border-color:#4b5563; }
    .input, select { background:#0f172a; color:#e5e7eb; border:1px solid #334155; border-radius:8px; padding:8px 10px; }
    .card { background: var(--card); border:1px solid #1f2937; border-radius:12px; padding:12px; }
    .grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(220px,1fr)); gap:10px; }
    .muted { color: var(--muted); font-size:12px; }
    .kpi { font-size:22px; font-weight:700; }
    .drpz { border:2px dashed #334155; border-radius:12px; padding:12px; text-align:center; color:#9ca3af; }
    .preset .btn { font-size:12px; padding:6px 8px; }
    .toast { position:fixed; right:16px; bottom:16px; background:#111827; border:1px solid #374151; border-radius:10px; padding:10px 12px; color:#e5e7eb; opacity:0.95; }
    table { width:100%; border-collapse:collapse; }
    th, td { padding:6px 8px; border-bottom:1px solid #1f2937; font-size:12px; text-align:right; }
    th:first-child, td:first-child { text-align:left; }
    .pos { color: var(--good); } .neg { color: var(--bad); }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
</head>
<body>
<div class="wrap">
  <aside class="side">
    <h1>Trade4V Viewer Pro v2.4</h1>
    <div class="section">
      <div class="muted">파일 드래그 앤 드롭 (창 어디든 가능)</div>
      <div id="drop" class="drpz">여기로 <b>preds.csv</b> + <b>metrics_oos.json</b> 드롭</div>
      <div style="height:8px"></div>
      <div class="row"><input class="input" type="file" id="predsFile" accept=".csv" /><input class="input" type="file" id="metricsFile" accept="application/json" /></div>
      <div class="row"><button class="btn" id="btnForceRefresh">강제 새로고침</button><span id="status" class="muted">-</span></div>
    </div>
    <div class="section">
      <div class="muted">URL로 불러오기 (raw 링크)</div>
      <input class="input" id="predsURL" placeholder="preds.csv raw URL">
      <input class="input" id="metricsURL" placeholder="metrics.json raw URL">
      <div class="row"><button class="btn" id="btnLoadURL">불러오기</button><span id="loadMsg" class="muted"></span></div>
    </div>
    <div class="section preset">
      <div class="muted">기간 빠른 선택</div>
      <div class="row">
        <button class="btn" data-range="1D">1D</button>
        <button class="btn" data-range="1W">1W</button>
        <button class="btn" data-range="1M">1M</button>
        <button class="btn" data-range="3M">3M</button>
        <button class="btn" data-range="YTD">YTD</button>
        <button class="btn" data-range="ALL">ALL</button>
      </div>
    </div>
    <div class="section">
      <div class="muted">기간 수동 선택</div>
      <div class="row">
        <input class="input" id="start" type="datetime-local">
        <input class="input" id="end" type="datetime-local">
      </div>
      <div class="row">
        <button class="btn" id="btnApplyRange">적용</button>
        <button class="btn" id="btnResetAll">전체 리셋</button>
      </div>
      <div class="muted">휠 줌: 차트 위에서 마우스 휠(확대/축소), Shift+휠(좌/우로 이동)</div>
    </div>
    <div class="section">
      <div class="muted">레짐 필터</div>
      <div class="row">
        <label><input type="checkbox" id="rid0" checked> R0</label>
        <label><input type="checkbox" id="rid1" checked> R1</label>
        <label><input type="checkbox" id="rid2" checked> R2</label>
      </div>
    </div>
    <div class="section">
      <div class="muted">표시 요소</div>
      <div class="row" style="flex-direction:column; align-items:flex-start;">
        <label><input type="checkbox" id="showEquity" checked> 누적 PnL 라인</label>
        <label><input type="checkbox" id="showBars" checked> 일별 PnL 바</label>
        <label><input type="checkbox" id="showScatter" checked> EV vs 실현 산포</label>
        <label><input type="checkbox" id="showHist" checked> EV 히스토그램</label>
        <label><input type="checkbox" id="showDD" checked> 드로우다운</label>
        <label><input type="checkbox" id="showMCC" checked> 기간별 MCC</label>
      </div>
    </div>
    <div class="section">
      <div class="muted">스무딩(Equity)</div>
      <select id="smooth" class="input">
        <option value="1">x1</option>
        <option value="5">x5</option>
        <option value="15">x15</option>
      </select>
    </div>
    <div class="section">
      <div class="muted">스키마</div>
      <div id="schemaInfo" class="muted">-</div>
    </div>
  </aside>

  <main class="main">
    <div class="grid">
      <div class="card"><div class="muted">Trades</div><div id="k_trades" class="kpi">-</div></div>
      <div class="card"><div class="muted">Hit rate</div><div id="k_hit" class="kpi">-</div></div>
      <div class="card"><div class="muted">PnL (sum)</div><div id="k_pnl" class="kpi">-</div></div>
      <div class="card"><div class="muted">EV≥0 ratio</div><div id="k_evpos" class="kpi">-</div></div>
      <div class="card"><div class="muted">Eff (real/EV)</div><div id="k_eff" class="kpi">-</div></div>
      <div class="card"><div class="muted">Eff (real/EV·size)</div><div id="k_effw" class="kpi">-</div></div>
    </div>
    <div id="panelEquity" class="card"><canvas id="equity" height="140"></canvas></div>
    <div id="panelBars" class="card"><canvas id="barPnL" height="140"></canvas></div>
    <div id="panelDD" class="card"><canvas id="drawdown" height="140"></canvas></div>
    <div id="panelScatter" class="card"><canvas id="scatter" height="140"></canvas></div>
    <div id="panelHist" class="card"><canvas id="hist" height="120"></canvas></div>
    <div id="panelMCC" class="card" style="display:none;"><canvas id="mccChart" height="120"></canvas></div>
    <div class="card">
      <div class="muted">EV Deciles</div>
      <table id="deciles"><thead><tr><th>Bucket</th><th>Count</th><th>EV Sum</th><th>Realized Sum</th><th>Eff</th></tr></thead><tbody></tbody></table>
    </div>
    <div class="card">
      <div class="muted">Period Breakdown (Monthly)</div>
      <table id="periodTable">
        <thead><tr><th>Period</th><th>Trades</th><th>Hit%</th><th>PnL Sum</th><th>Cum PnL</th><th>Max DD</th><th>MCC</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </main>
</div>

<div id="toast" class="toast" style="display:none"></div>

<script>
window.addEventListener('DOMContentLoaded', () => {
  let RAW=null, MET=null, ALL=null, FILT=null, charts={};
  const needCols = ["time","regime_id","H_row","ev_final","entry_flag","size","gross_event","net_event"];
  const synonyms = {
    time: ["time","timestamp","open_time","date"],
    regime_id: ["regime_id","regime","state"],
    H_row: ["H_row","H_used","H","h_row","h_used","h"],
    ev_final: ["ev_final","ev_net","edge","pnl_pred","ev"],
    entry_flag: ["entry_flag","signal","enter","trade","flag"],
    size: ["size","kelly","weight","position","w","kelly_size"],
    gross_event: ["gross_event","event_gross","gross","ret_gross","gross_ret"],
    net_event: ["net_event","event_net","net","ret_net","net_ret","realized"]
  };
  const $ = id => document.getElementById(id);
  const safe = (id, text) => { const el=$(id); if(el) el.innerText = text; };
  function toast(msg){ const t=$('toast'); t.innerText=msg; t.style.display='block'; setTimeout(()=>{ t.style.display='none'; }, 2500); }
  function setStatus(msg){ const el=$('status'); if(el) el.innerText = msg; }
  function safeParseTime(v){
    if(typeof v === 'number'){ return new Date(v); }
    if(typeof v === 'string'){ if(!/[zZ]|[+\-]\d{2}:\d{2}$/.test(v)) v = v.replace(' ', 'T') + 'Z'; return new Date(v); }
    return new Date(v);
  }
  function mapHeaders(rows){
    if(!rows || !rows.length) return rows;
    const keys = Object.keys(rows[0]);
    const up = k=> k.toLowerCase().replace(/\s+/g,'');
    const dict = {};
    for(const req in synonyms){
      const cands = synonyms[req];
      for(const k of keys){
        const K = up(k);
        for(const c of cands){ if(K === up(c)){ dict[req] = k; break; } }
        if(dict[req]) break;
      }
    }
    return rows.map(r=>{
      const o={};
      for(const req of Object.keys(synonyms)){
        const k = dict[req];
        if(k !== undefined){ o[req] = r[k]; }
      }
      for(const k in r){ if(!(k in o)) o[k]=r[k]; }
      return o;
    });
  }
  function adaptRows(rows){
    if(!rows || rows.length===0) return rows;
    rows = rows.map(obj=>{ const r={}; for(const k in obj){ r[k.trim()] = obj[k]; } return r; });
    rows = mapHeaders(rows);
    const has = k=> Object.prototype.hasOwnProperty.call(rows[0], k);
    let out = rows.map(r=>({...r}));
    if(!has("ev_final") && has("ev_net")) out = out.map(r=>({...r, ev_final:Number(r.ev_net)}));
    const miss = needCols.filter(c=> !(c in out[0]));
    if(miss.length) throw new Error("필수 컬럼 누락: "+miss.join(", "));
    return out;
  }
  function derive(rows, start=null, end=null, ridMask={0:true,1:true,2:true}, smooth=1){
    const p = rows.map(r=>({ ...r,
      time: safeParseTime(r.time), regime_id: Number(r.regime_id), H_row: Number(r.H_row||1),
      ev_final: Number(r.ev_final||0), entry_flag: Number(r.entry_flag||0), size: Number(r.size||0),
      gross_event: Number(r.gross_event||0), net_event: Number(r.net_event||0),
    })).filter(r=> ridMask[r.regime_id]);
    const p2 = p.filter(r=> (!start || r.time>=start) && (!end || r.time<=end));
    const selected = p2.filter(r=> r.entry_flag===1);
    const withSize = selected.map(r=> ({...r, dir_pred: Math.sign(r.ev_final||0)||1, dir_real: Math.sign(r.gross_event||0)||-1,
                                         pnl: r.net_event*r.size, exit: new Date(r.time.getTime()+r.H_row*60*1000)}));
    const pnl = withSize.reduce((a,r)=>a+r.pnl,0);
    const evSum = withSize.reduce((a,r)=>a+r.ev_final,0);
    const evWSum= withSize.reduce((a,r)=>a+r.ev_final*r.size,0);
    const eff = evSum>0 ? pnl/evSum : 0;
    const effW= evWSum>0? pnl/evWSum: 0;
    const wins = withSize.filter(r=> r.gross_event>0).length;
    const hit = selected.length? wins/selected.length : 0;
    const evPos = p2.length? p2.filter(r=> r.ev_final>=0).length/p2.length : 0;

    const impulses = withSize.map(r=> ({ t:r.exit, v:r.pnl })).sort((a,b)=>a.t-b.t);
    let cum=0; const series = impulses.map(s=> ({ t:s.t, cum:(cum+=s.v) }));

    const dayMap={}; withSize.forEach(r=>{ const k=r.exit.toISOString().slice(0,10); dayMap[k]=(dayMap[k]||0)+r.pnl; });
    const days = Object.keys(dayMap).sort().map(k=> ({ day:k, pnl: dayMap[k] }));

    const scatter = withSize.map(r=> ({ x:r.ev_final, y:r.pnl }));
    const evs = p2.map(r=> r.ev_final);

    // Drawdown
    let peak = 0, eq=0, ddSeries=[];
    series.forEach(s=>{ eq=s.cum; peak=Math.max(peak, eq); ddSeries.push({t:s.t, dd: peak - eq}); });

    // Period breakdown (monthly)
    function yyyymm(d){ return d.getUTCFullYear()+"-"+String(d.getUTCMonth()+1).padStart(2,'0'); }
    const per = {};
    let cumPnL=0;
    const byExit = withSize.slice().sort((a,b)=>a.exit-b.exit);
    let eqPeak=0, eqNow=0;
    byExit.forEach(r=>{
      const m = yyyymm(r.exit);
      per[m] = per[m] || { trades:0, wins:0, pnl:0, cum:0, mccN:{tp:0,tn:0,fp:0,fn:0}, dd:0, eq:0 };
      per[m].trades += 1;
      per[m].wins += (r.gross_event>0?1:0);
      per[m].pnl  += r.pnl;
      // MCC on executed trades using dir_pred vs dir_real
      const pred = r.dir_pred>=0? 1:0;
      const real = r.dir_real>=0? 1:0;
      if(pred===1 && real===1) per[m].mccN.tp += 1;
      else if(pred===0 && real===0) per[m].mccN.tn += 1;
      else if(pred===1 && real===0) per[m].mccN.fp += 1;
      else if(pred===0 && real===1) per[m].mccN.fn += 1;
      // rolling equity & drawdown
      eqNow += r.pnl; eqPeak = Math.max(eqPeak, eqNow); const dd = eqPeak - eqNow;
      per[m].dd = Math.max(per[m].dd, dd);
    });
    const periods = Object.keys(per).sort();
    const periodRows = [];
    periods.forEach(m=>{
      const o = per[m];
      cumPnL += o.pnl;
      const n = o.trades||1;
      const hr = o.wins/n;
      const N = o.mccN; const denom = (N.tp+N.fp)*(N.tp+N.fn)*(N.tn+N.fp)*(N.tn+N.fn);
      let mcc = 0; if(denom>0){
        mcc = ((N.tp*N.tn - N.fp*N.fn) / Math.sqrt(denom)) || 0;
      }
      periodRows.push({ period:m, trades:o.trades, hit:hr, pnl:o.pnl, cum:cumPnL, maxdd:o.dd, mcc:mcc });
    });

    // MCC time series for chart
    const mccSeries = periodRows.map(r=> ({ x:r.period, y:r.mcc }));

    return { selected, pnl, hit, evPos, eff, effW, trades:selected.length, series, days, scatter, evs, ddSeries,
             deciles: computeDeciles(withSize), periodRows, mccSeries,
             tmin: p2.length? p2[0].time : null, tmax: p2.length? p2[p2.length-1].time : null };
  }
  function computeDeciles(withSize){
    const evSel = withSize.map(r=> r.ev_final).slice().sort((a,b)=>a-b);
    const buckets = 10; let cuts=[];
    for(let i=1;i<buckets;i++){ const q = i/buckets; const idx = Math.floor(q*(evSel.length-1)); cuts.push(evSel.length? evSel[idx]:0); }
    function bucketOf(v){ let b=0; while(b<cuts.length && v>cuts[b]) b++; return b; }
    const agg = Array.from({length:buckets},()=>({cnt:0, ev:0, real:0}));
    withSize.forEach(r=>{ const b = bucketOf(r.ev_final); agg[b].cnt++; agg[b].ev += r.ev_final; agg[b].real += r.pnl; });
    return agg.map((g,i)=>({ bucket:`D${i+1}`, cnt:g.cnt, ev:g.ev, real:g.real, eff: (g.ev>0? g.real/g.ev:0) }));
  }

  function mkChart(id, cfg){
    const el=$(id); if(!el) return;
    if(charts[id]) charts[id].destroy();
    charts[id] = new Chart(el, cfg);
  }

  function draw(d){
    safe("k_trades", String(d.trades));
    safe("k_hit", (d.hit*100).toFixed(1)+"%");
    safe("k_pnl", d.pnl.toFixed(4));
    safe("k_evpos", (d.evPos*100).toFixed(1)+"%");
    safe("k_eff", d.eff.toFixed(3));
    safe("k_effw", d.effW.toFixed(3));

    const show = (panel, flag)=>{ const p=$(panel), f=$(flag); if(p&&f) p.style.display = f.checked? 'block':'none'; };
    show("panelEquity","showEquity"); show("panelBars","showBars"); show("panelScatter","showScatter"); show("panelHist","showHist"); show("panelDD","showDD");
    show("panelMCC","showMCC");

    // Equity (cum PnL)
    if($("showEquity")?.checked){
      const labels = d.series.map(s=> s.t);
      const data = d.series.map(s=> s.cum);
      const smooth = parseInt($("smooth")?.value||"1",10);
      let smData=data;
      if(smooth>1 && data.length>smooth){
        smData=[]; for(let i=0;i<data.length;i++){ const a=Math.max(0, i-smooth+1); const chunk=data.slice(a,i+1); smData.push(chunk.reduce((x,y)=>x+y,0)/chunk.length); }
      }
      mkChart('equity', { type:'line', data:{ labels, datasets:[{ label:'Cumulative PnL', data: smData, pointRadius:0 }]},
        options:{ parsing:false, scales:{ x:{ type:'time' } } } });
    }

    if($("showBars")?.checked){
      mkChart('barPnL', { type:'bar', data:{ labels: d.days.map(x=> x.day), datasets:[{ label:'Daily PnL', data: d.days.map(x=> x.pnl) }]},
                           options:{ scales:{ x:{ ticks:{ maxRotation:0 } } } } });
    }

    if($("showDD")?.checked){
      mkChart('drawdown', { type:'line', data:{ labels: d.ddSeries.map(s=> s.t), datasets:[{ label:'Drawdown', data: d.ddSeries.map(s=> s.dd), pointRadius:0 }]},
                            options:{ parsing:false, scales:{ x:{ type:'time' } } } });
    }

    if($("showScatter")?.checked){
      mkChart('scatter', { type:'scatter', data:{ datasets:[{ label:'EV vs Realized', data: d.scatter }]},
                           options:{ scales:{ x:{ title:{display:true,text:'EV(final)'}}, y:{ title:{display:true,text:'Realized(net*size)'}} } } });
    }

    if($("showHist")?.checked){
      const evs = d.evs.slice().sort((a,b)=>a-b);
      const bins = 30; const min = evs.length? evs[0]:0; const max = evs.length? evs[evs.length-1]:1;
      const step = (max-min)/(bins||1) || 1;
      const edges = Array.from({length:bins}, (_,i)=> min + i*step);
      const counts = Array.from({length:bins}, ()=>0);
      evs.forEach(v=>{ const idx = Math.max(0, Math.min(bins-1, Math.floor((v-min)/step))); counts[idx]++; });
      const centers = edges.map((e,i)=> e + step/2);
      mkChart('hist', { type:'bar', data:{ labels: centers, datasets:[{ label:'EV Histogram', data: counts }]},
                        options:{ scales:{ x:{ ticks:{ display:false }}} } });
    }

    // MCC chart
    if($("showMCC")?.checked){
      mkChart('mccChart', { type:'bar', data:{ labels: d.mccSeries.map(p=> p.x), datasets:[{ label:'MCC by Month', data: d.mccSeries.map(p=> p.y) }]},
                            options:{ scales:{ y:{ min:-1, max:1 } } } });
    }

    // Deciles table
    const tb = document.querySelector("#deciles tbody"); if(tb){ tb.innerHTML=""; d.deciles.forEach(g=>{
      const tr=document.createElement("tr");
      const eff = (g.ev>0)? (g.real/g.ev) : 0;
      tr.innerHTML = `<td>${g.bucket}</td><td>${g.cnt}</td><td>${g.ev.toFixed(4)}</td><td class="${g.real>=0?'pos':'neg'}">${g.real.toFixed(4)}</td><td>${eff.toFixed(3)}</td>`;
      tb.appendChild(tr);
    }); }

    // Period table
    const pt = document.querySelector("#periodTable tbody"); if(pt){ pt.innerHTML="";
      d.periodRows.forEach(r=>{
        const tr=document.createElement("tr");
        tr.innerHTML = `<td>${r.period}</td><td>${r.trades}</td><td>${(r.hit*100).toFixed(1)}%</td><td class="${r.pnl>=0?'pos':'neg'}">${r.pnl.toFixed(4)}</td><td>${r.cum.toFixed(4)}</td><td>${r.maxdd.toFixed(4)}</td><td>${r.mcc.toFixed(3)}</td>`;
        pt.appendChild(tr);
      });
    }
  }

  function getFilters(){
    const s = $('start')?.value;
    const e = $('end')?.value;
    const start = s ? new Date(s) : null;
    const end   = e ? new Date(e) : null;
    const ridMask = {0:$('rid0')?.checked!==false, 1:$('rid1')?.checked!==false, 2:$('rid2')?.checked!==false};
    const smooth = parseInt($('smooth')?.value||"1",10);
    return { start, end, ridMask, smooth };
  }

  function refresh(){
    if(!ALL || !ALL.rows) return;
    const { start, end, ridMask, smooth } = getFilters();
    FILT = derive(ALL.rows, start, end, ridMask, smooth);
    const sch = ALL.metrics?.viewer_schema || "v1?";
    const el=$('schemaInfo'); if(el) el.innerText = "viewer_schema: " + sch;
    draw(FILT);
  }

  function afterLoad(){
    if(!RAW && !MET){ setStatus("-"); return; }
    const name1 = ALL?.names?.preds || "-";
    const name2 = ALL?.names?.metrics || "-";
    setStatus(`로드됨: ${name1} / ${name2} (rows=${(ALL.rows||[]).length||0})`);
    try{
      const rows = ALL.rows;
      if(rows && rows.length){
        const t0 = safeParseTime(rows[0].time);
        const t1 = safeParseTime(rows[rows.length-1].time);
        const toLocal = t=> new Date(t.getTime() - t.getTimezoneOffset()*60000).toISOString().slice(0,16);
        if($('start')) $('start').value = toLocal(t0);
        if($('end'))   $('end').value   = toLocal(t1);
      }
    }catch(err){}
    refresh();
  }

  async function handleFiles(files){
    const arr = Array.from(files||[]);
    if(arr.length===0) return;
    let changed=false;
    for(const f of arr){
      try{
        if(f.name.endsWith(".csv")){
          const r = await new Promise((res,rej)=> Papa.parse(f,{header:true,dynamicTyping:true,complete:r=>res(r.data),error:rej}));
          RAW = adaptRows(r); changed=true;
          ALL = ALL || {}; ALL.rows = RAW; ALL.names = ALL.names || {}; ALL.names.preds = f.name;
        }else if(f.name.endsWith(".json")){
          const text = await f.text(); MET = JSON.parse(text); changed=true;
          ALL = ALL || {}; ALL.metrics = MET; ALL.names = ALL.names || {}; ALL.names.metrics = f.name;
        }else{
          toast("지원하지 않는 파일: "+f.name);
        }
      }catch(err){
        toast("로딩 실패: "+err.message);
        console.error(err);
      }
    }
    if(changed) afterLoad();
  }

  async function fetchText(url){ const r=await fetch(url, {cache:'no-store'}); if(!r.ok) throw new Error(r.statusText); return r.text(); }

  // Wire inputs
  $('predsFile')?.addEventListener("change", e=> handleFiles(e.target.files));
  $('metricsFile')?.addEventListener("change", e=> handleFiles(e.target.files));
  $('btnForceRefresh')?.addEventListener("click", refresh);
  ['rid0','rid1','rid2','showEquity','showBars','showScatter','showHist','showDD','showMCC','smooth'].forEach(id=>{
    const el=$(id); if(el) el.addEventListener("change", refresh);
  });
  document.querySelectorAll(".preset .btn").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      if(!ALL?.rows?.length) return;
      const rows = ALL.rows; const last = new Date(rows[rows.length-1].time); const first= new Date(rows[0].time);
      function minusDays(d){ const x = new Date(last); x.setDate(x.getDate()-d); return x; }
      let s=first, e=last; const label = btn.getAttribute("data-range");
      if(label==="1D") s = minusDays(1);
      if(label==="1W") s = minusDays(7);
      if(label==="1M") s = minusDays(30);
      if(label==="3M") s = minusDays(90);
      if(label==="YTD"){ s = new Date(last.getUTCFullYear(),0,1); }
      setRange(s,e); refresh();
    });
  });
  $('btnApplyRange')?.addEventListener("click", refresh);
  $('btnResetAll')?.addEventListener("click", ()=>{
    if(ALL?.rows?.length){
      const t0 = new Date(ALL.rows[0].time); const t1 = new Date(ALL.rows[ALL.rows.length-1].time);
      setRange(t0,t1);
    }
    ['rid0','rid1','rid2','showEquity','showBars','showScatter','showHist','showDD','showMCC'].forEach(id=>{ if($(id)) $(id).checked=true; });
    if($('smooth')) $('smooth').value="1";
    refresh();
  });

  // Window drag&drop
  ["dragenter","dragover","dragleave","drop"].forEach(evt=>{
    document.addEventListener(evt, e=>{ if(evt!=="drop"){ e.preventDefault(); } }, false);
  });
  document.addEventListener("dragover", e=>{ e.preventDefault(); $('drop').style.background="#0b1220"; });
  document.addEventListener("dragleave", e=>{ $('drop').style.background=""; });
  document.addEventListener("drop", e=>{
    e.preventDefault(); $('drop').style.background="";
    const items = e.dataTransfer?.files;
    if(items && items.length){ handleFiles(items); toast("드래그 파일 로드 완료"); }
  });

  // URL load
  $('btnLoadURL')?.addEventListener("click", async ()=>{
    const u1 = $('predsURL')?.value.trim(); const u2 = $('metricsURL')?.value.trim();
    $('loadMsg').innerText = "불러오는 중...";
    try{
      if(u1){ const t1 = await fetchText(u1); RAW = adaptRows(Papa.parse(t1, {header:true, dynamicTyping:true}).data); ALL = ALL || {}; ALL.rows=RAW; ALL.names=ALL.names||{}; ALL.names.preds=u1; }
      if(u2){ const t2 = await fetchText(u2); MET = JSON.parse(t2); ALL = ALL || {}; ALL.metrics=MET; ALL.names=ALL.names||{}; ALL.names.metrics=u2; }
      $('loadMsg').innerText = "완료"; afterLoad();
    }catch(err){ $('loadMsg').innerText = "실패: "+err.message; }
  });

  // ===== Wheel zoom & pan (no external plugin) =====
  function setRange(s,e){
    const toLocal = t=> new Date(t.getTime() - t.getTimezoneOffset()*60000).toISOString().slice(0,16);
    if($('start')) $('start').value = toLocal(s);
    if($('end'))   $('end').value   = toLocal(e);
  }
  function getCurrentRange(){
    const s = $('start')?.value; const e = $('end')?.value;
    let start = s? new Date(s): null; let end = e? new Date(e): null;
    if(!start || !end){
      if(ALL?.rows?.length){ start = new Date(ALL.rows[0].time); end = new Date(ALL.rows[ALL.rows.length-1].time); }
    }
    return {start, end};
  }
  function wheelZoomHandler(e){
    if(!ALL?.rows?.length) return;
    e.preventDefault();
    const {start, end} = getCurrentRange(); if(!start || !end) return;
    const span = end - start; if(span<=0) return;
    const factor = 1 + (e.deltaY>0 ? 0.1 : -0.1); // 10% per wheel notch
    let newSpan = Math.max(60*1000, span * factor); // min 1 minute
    // center-based zoom
    const mid = new Date((start.getTime()+end.getTime())/2);
    let ns = new Date(mid.getTime() - newSpan/2);
    let ne = new Date(mid.getTime() + newSpan/2);
    // Shift when Shift key pressed
    if(e.shiftKey){
      const shift = span * 0.1 * (e.deltaY>0 ? 1 : -1);
      ns = new Date(start.getTime() + shift);
      ne = new Date(end.getTime() + shift);
    }
    // clamp to data
    const d0 = new Date(ALL.rows[0].time); const d1 = new Date(ALL.rows[ALL.rows.length-1].time);
    if(ns<d0){ ns=d0; ne=new Date(ns.getTime()+newSpan); }
    if(ne>d1){ ne=d1; ns=new Date(ne.getTime()-newSpan); }
    setRange(ns, ne); refresh();
  }
  ['equity','barPnL','drawdown'].forEach(id=>{
    const el=$(id); if(el){ el.addEventListener('wheel', wheelZoomHandler, {passive:false}); }
  });

});
</script>
</body>
</html>
